{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Autonomi Documentation","text":"<p>Welcome to the Autonomi documentation! This guide will help you get started with using the Autonomi network client.</p>"},{"location":"#what-is-autonomi","title":"What is Autonomi?","text":"<p>Autonomi is a decentralised data and communications platform designed to provide complete privacy, security, and freedom by distributing data across a peer-to-peer network, rather than relying on centralised servers. Through end-to-end encryption, self-authentication, and the allocation of storage and bandwidth from users\u2019 own devices, it seeks to create an autonomous, self-sustaining system where data ownership remains firmly in the hands of individuals rather than corporations.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide</li> <li>Core Concepts:</li> <li>Data Types - Understanding the fundamental data structures</li> <li>Client Modes - Different operational modes of the client</li> <li>Data Storage - How data is stored and retrieved</li> <li>Local Network Setup - Setting up a local development environment</li> </ul>"},{"location":"#api-references","title":"API References","text":"<ul> <li>Autonomi Client - Core client library for network operations</li> <li>Ant Node - Node implementation for network participation</li> <li>BLS Threshold Crypto - Threshold cryptography implementation</li> <li>Self Encryption - Content-based encryption library</li> <li>Developer Resources:</li> </ul>"},{"location":"#language-support","title":"Language Support","text":"<p>Autonomi provides client libraries for multiple languages:</p> Node.jsPythonRust <pre><code>import { Client } from 'autonomi';\n\nconst client = new Client();\nawait client.connect();\n</code></pre> <pre><code>from autonomi import Client\n\nclient = Client()\nawait client.connect()\n</code></pre> <pre><code>use autonomi::Client;\n\nlet client = Client::new()?;\n</code></pre>"},{"location":"#building-from-source","title":"Building from Source","text":"Python (using Maturin &amp; uv)Node.jsRust <pre><code># Install build dependencies\ncurl -LsSf &lt;https://astral.sh/uv/install.sh&gt; | sh\nuv pip install maturin\n\n# Clone the repository\ngit clone https://github.com/dirvine/autonomi.git\ncd autonomi\n\n# Create and activate virtual environment\nuv venv\nsource .venv/bin/activate  # Unix\n# or\n.venv\\Scripts\\activate     # Windows\n\n# Build and install the package\ncd python\nmaturin develop\n\n# Install dependencies\nuv pip install -r requirements.txt\n</code></pre> <pre><code># Install build dependencies\nnpm install -g node-gyp\n\n# Clone the repository\ngit clone https://github.com/dirvine/autonomi.git\ncd autonomi\n\n# Build the Node.js bindings\ncd nodejs\nnpm install\nnpm run build\n\n# Link for local development\nnpm link\n</code></pre> <pre><code># Clone the repository\ngit clone &lt;https://github.com/dirvine/autonomi.git&gt;\ncd autonomi\n\n# Build the project\ncargo build --release\n\n# Run tests\ncargo test --all-features\n\n# Install locally\ncargo install --path .\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions! Here's how you can help:</p> <ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make your changes</li> <li>Submit a pull request</li> </ol> <p>For more details, see our Contributing Guide.</p>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>GitHub Issues</li> <li>API References:</li> <li>Autonomi Client</li> <li>Ant Node</li> <li>BLS Threshold Crypto</li> <li>Self Encryption</li> <li>Testing Guide</li> </ul>"},{"location":"api/","title":"API Reference Overview","text":"<p>Autonomi provides several APIs for different aspects of the system:</p>"},{"location":"api/#client-api","title":"Client API","text":"<p>The Autonomi Client API is the core library for interacting with the Autonomi network. It provides:</p> <ul> <li>Data storage and retrieval</li> <li>Pointer management</li> <li>Linked list operations</li> <li>File system operations</li> <li>Error handling</li> </ul>"},{"location":"api/#node-api","title":"Node API","text":"<p>The Ant Node API allows you to run and manage nodes in the Autonomi network. Features include:</p> <ul> <li>Node setup and configuration</li> <li>Network participation</li> <li>Storage management</li> <li>Reward collection</li> <li>Event handling</li> </ul>"},{"location":"api/#cryptography-apis","title":"Cryptography APIs","text":""},{"location":"api/#bls-threshold-crypto","title":"BLS Threshold Crypto","text":"<p>The BLS Threshold Crypto API implements BLS (Boneh-Lynn-Shacham) threshold signatures, providing:</p> <ul> <li>Secret key generation and sharing</li> <li>Signature creation and verification</li> <li>Threshold signature schemes</li> <li>Key aggregation</li> </ul>"},{"location":"api/#self-encryption","title":"Self Encryption","text":"<p>The Self Encryption API implements content-based encryption, offering:</p> <ul> <li>Data-derived encryption</li> <li>Content deduplication</li> <li>Parallel processing</li> <li>Streaming interface</li> </ul>"},{"location":"api/#language-support","title":"Language Support","text":"<p>All APIs are available in multiple languages:</p> <ul> <li>Python (3.8+)</li> <li>Rust (stable)</li> <li>Node.js (16+)</li> </ul> <p>Each API section includes language-specific installation instructions and code examples.</p>"},{"location":"api/ant-node/","title":"Ant Node API Reference","text":"<p>The Ant Node provides a comprehensive API for running and managing nodes in the Autonomi network. This documentation covers both the Python bindings and the Rust implementation.</p>"},{"location":"api/ant-node/#installation","title":"Installation","text":"PythonRust <pre><code># Install using uv (recommended)\ncurl -LsSf &lt;https://astral.sh/uv/install.sh&gt; | sh\nuv pip install maturin\nuv pip install antnode\n\n# Or using pip\npip install antnode\n</code></pre> <pre><code># Add to Cargo.toml\n[dependencies]\nant-node = \"0.3.2\"\n</code></pre>"},{"location":"api/ant-node/#basic-usage","title":"Basic Usage","text":"PythonRust <pre><code>from antnode import AntNode\n\n# Create and start a node\nnode = AntNode()\nnode.run(\n    rewards_address=\"0x1234567890123456789012345678901234567890\",  # Your EVM wallet address\n    evm_network=\"arbitrum_sepolia\",  # or \"arbitrum_one\" for mainnet\n    ip=\"0.0.0.0\",\n    port=12000,\n    initial_peers=[\n        \"/ip4/142.93.37.4/udp/40184/quic-v1/p2p/12D3KooWPC8q7QGZsmuTtCYxZ2s3FPXPZcS8LVKkayXkVFkqDEQB\",\n    ],\n    local=False,\n    root_dir=None,  # Uses default directory\n    home_network=False\n)\n</code></pre> <pre><code>use ant_node::{NodeBuilder, NodeEvent};\nuse ant_evm::RewardsAddress;\nuse libp2p::Multiaddr;\n\n// Create and start a node\nlet node = NodeBuilder::new()\n    .rewards_address(rewards_address)\n    .evm_network(evm_network)\n    .ip(ip)\n    .port(port)\n    .initial_peers(initial_peers)\n    .local(false)\n    .root_dir(None)\n    .home_network(false)\n    .build()?;\n</code></pre>"},{"location":"api/ant-node/#core-features","title":"Core Features","text":""},{"location":"api/ant-node/#node-information","title":"Node Information","text":"PythonRust <pre><code># Get node's peer ID\npeer_id = node.peer_id()\n\n# Get current rewards address\naddress = node.get_rewards_address()\n\n# Get routing table information\nkbuckets = node.get_kbuckets()\nfor distance, peers in kbuckets:\n    print(f\"Distance {distance}: {len(peers)} peers\")\n\n# Get all stored record addresses\nrecords = node.get_all_record_addresses()\n</code></pre> <pre><code>// Get node's peer ID\nlet peer_id = node.peer_id();\n\n// Get current rewards address\nlet address = node.rewards_address();\n\n// Get routing table information\nlet kbuckets = node.get_kbuckets()?;\nfor (distance, peers) in kbuckets {\n    println!(\"Distance {}: {} peers\", distance, peers.len());\n}\n\n// Get all stored record addresses\nlet records = node.get_all_record_addresses()?;\n</code></pre>"},{"location":"api/ant-node/#storage-operations","title":"Storage Operations","text":"PythonRust <pre><code># Store data\nkey = \"0123456789abcdef\"  # Hex string\nvalue = b\"Hello, World!\"\nnode.store_record(key, value, \"chunk\")\n\n# Retrieve data\ndata = node.get_record(key)\n\n# Delete data\nsuccess = node.delete_record(key)\n\n# Get total storage size\nsize = node.get_stored_records_size()\n</code></pre> <pre><code>use ant_protocol::storage::ValidationType;\n\n// Store data\nlet key = \"0123456789abcdef\";  // Hex string\nlet value = b\"Hello, World!\";\nnode.store_record(key, value, ValidationType::Chunk)?;\n\n// Retrieve data\nlet data = node.get_record(key)?;\n\n// Delete data\nlet success = node.delete_record(key)?;\n\n// Get total storage size\nlet size = node.get_stored_records_size()?;\n</code></pre>"},{"location":"api/ant-node/#directory-management","title":"Directory Management","text":"PythonRust <pre><code># Get various directory paths\nroot_dir = node.get_root_dir()\nlogs_dir = node.get_logs_dir()\ndata_dir = node.get_data_dir()\n\n# Get default directory for a specific peer\ndefault_dir = AntNode.get_default_root_dir(peer_id)\n</code></pre> <pre><code>// Get various directory paths\nlet root_dir = node.root_dir();\nlet logs_dir = node.logs_dir();\nlet data_dir = node.data_dir();\n\n// Get default directory for a specific peer\nlet default_dir = Node::get_default_root_dir(peer_id)?;\n</code></pre>"},{"location":"api/ant-node/#event-handling","title":"Event Handling","text":"PythonRust <pre><code># Event handling is automatic in Python bindings\n# Events are logged and can be monitored through the logging system\n</code></pre> <pre><code>use ant_node::{NodeEvent, NodeEventsReceiver};\n\n// Get event receiver\nlet mut events: NodeEventsReceiver = node.event_receiver();\n\n// Handle events\nwhile let Ok(event) = events.recv().await {\n    match event {\n        NodeEvent::ConnectedToNetwork =&gt; println!(\"Connected to network\"),\n        NodeEvent::ChunkStored(addr) =&gt; println!(\"Chunk stored: {}\", addr),\n        NodeEvent::RegisterCreated(addr) =&gt; println!(\"Register created: {}\", addr),\n        NodeEvent::RegisterEdited(addr) =&gt; println!(\"Register edited: {}\", addr),\n        NodeEvent::RewardReceived(amount, addr) =&gt; {\n            println!(\"Reward received: {} at {}\", amount, addr)\n        }\n        NodeEvent::ChannelClosed =&gt; break,\n        NodeEvent::TerminateNode(reason) =&gt; {\n            println!(\"Node terminated: {}\", reason);\n            break;\n        }\n    }\n}\n</code></pre>"},{"location":"api/ant-node/#configuration-options","title":"Configuration Options","text":""},{"location":"api/ant-node/#node-configuration","title":"Node Configuration","text":"<ul> <li><code>rewards_address</code>: EVM wallet address for receiving rewards</li> <li><code>evm_network</code>: Network to use (\"arbitrum_sepolia\" or \"arbitrum_one\")</li> <li><code>ip</code>: IP address to listen on</li> <li><code>port</code>: Port to listen on</li> <li><code>initial_peers</code>: List of initial peers to connect to</li> <li><code>local</code>: Whether to run in local mode</li> <li><code>root_dir</code>: Custom root directory path</li> <li><code>home_network</code>: Whether the node is behind NAT</li> </ul>"},{"location":"api/ant-node/#network-types","title":"Network Types","text":"<ul> <li><code>arbitrum_sepolia</code>: Test network</li> <li><code>arbitrum_one</code>: Main network</li> </ul>"},{"location":"api/ant-node/#error-handling","title":"Error Handling","text":"PythonRust <pre><code>try:\n    node.store_record(key, value, \"chunk\")\nexcept Exception as e:\n    print(f\"Error storing record: {e}\")\n</code></pre> <pre><code>use ant_node::error::Error;\n\nmatch node.store_record(key, value, ValidationType::Chunk) {\n    Ok(_) =&gt; println!(\"Record stored successfully\"),\n    Err(Error::StorageFull) =&gt; println!(\"Storage is full\"),\n    Err(Error::InvalidKey) =&gt; println!(\"Invalid key format\"),\n    Err(e) =&gt; println!(\"Other error: {}\", e),\n}\n</code></pre>"},{"location":"api/ant-node/#best-practices","title":"Best Practices","text":"<ol> <li>Error Handling</li> <li>Always handle potential errors appropriately</li> <li>Implement retry logic for network operations</li> <li> <p>Log errors for debugging</p> </li> <li> <p>Resource Management</p> </li> <li>Monitor storage usage</li> <li>Clean up unused records</li> <li> <p>Handle events promptly</p> </li> <li> <p>Network Operations</p> </li> <li>Use appropriate timeouts</li> <li>Handle network disconnections</li> <li> <p>Maintain peer connections</p> </li> <li> <p>Security</p> </li> <li>Validate input data</li> <li>Secure storage of keys</li> <li>Regular backups of important data</li> </ol>"},{"location":"api/ant-node/configuration/","title":"Node Configuration","text":"<p>This page documents the configuration options for running an Ant Node.</p>"},{"location":"api/ant-node/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"api/ant-node/configuration/#network-configuration","title":"Network Configuration","text":"PythonRust <pre><code>from antnode import NodeConfig\n\nconfig = NodeConfig(\n    # Network settings\n    ip=\"0.0.0.0\",              # IP address to listen on\n    port=12000,                # Port to listen on\n    evm_network=\"arbitrum_sepolia\",  # EVM network to use\n    rewards_address=\"0x...\",   # EVM wallet address for rewards\n\n    # Node settings\n    local=False,               # Run in local mode\n    home_network=False,        # Node is behind NAT\n    root_dir=None,             # Custom root directory\n\n    # Network peers\n    initial_peers=[            # Bootstrap peers\n        \"/ip4/142.93.37.4/udp/40184/quic-v1/p2p/12D3KooWPC8q7QGZsmuTtCYxZ2s3FPXPZcS8LVKkayXkVFkqDEQB\",\n    ]\n)\n</code></pre> <pre><code>use ant_node::{NodeConfig, RewardsAddress};\nuse std::path::PathBuf;\n\nlet config = NodeConfig::builder()\n    // Network settings\n    .ip(\"0.0.0.0\")\n    .port(12000)\n    .evm_network(\"arbitrum_sepolia\")\n    .rewards_address(RewardsAddress::new(\"0x...\"))\n\n    // Node settings\n    .local(false)\n    .home_network(false)\n    .root_dir(Some(PathBuf::from(\"/path/to/data\")))\n\n    // Network peers\n    .initial_peers(vec![\n        \"/ip4/142.93.37.4/udp/40184/quic-v1/p2p/12D3KooWPC8q7QGZsmuTtCYxZ2s3FPXPZcS8LVKkayXkVFkqDEQB\"\n            .parse()\n            .unwrap()\n    ])\n    .build()?;\n</code></pre>"},{"location":"api/ant-node/configuration/#storage-configuration","title":"Storage Configuration","text":"PythonRust <pre><code>from antnode import StorageConfig\n\nstorage_config = StorageConfig(\n    max_size=1024 * 1024 * 1024,  # 1GB max storage\n    min_free_space=1024 * 1024,    # 1MB min free space\n    cleanup_interval=3600,          # Cleanup every hour\n    backup_enabled=True,\n    backup_interval=86400,          # Daily backups\n    backup_path=\"/path/to/backups\"\n)\n\nconfig.storage = storage_config\n</code></pre> <pre><code>use ant_node::StorageConfig;\nuse std::path::PathBuf;\n\nlet storage_config = StorageConfig::builder()\n    .max_size(1024 * 1024 * 1024)  // 1GB max storage\n    .min_free_space(1024 * 1024)    // 1MB min free space\n    .cleanup_interval(3600)          // Cleanup every hour\n    .backup_enabled(true)\n    .backup_interval(86400)          // Daily backups\n    .backup_path(PathBuf::from(\"/path/to/backups\"))\n    .build()?;\n\nconfig.storage = storage_config;\n</code></pre>"},{"location":"api/ant-node/configuration/#network-types","title":"Network Types","text":"<p>The <code>evm_network</code> parameter can be one of:</p> <ul> <li><code>arbitrum_sepolia</code> - Test network</li> <li><code>arbitrum_one</code> - Main network</li> </ul>"},{"location":"api/ant-node/configuration/#directory-structure","title":"Directory Structure","text":"<p>The node uses the following directory structure:</p> <pre><code>root_dir/\n\u251c\u2500\u2500 data/           # Stored data chunks\n\u251c\u2500\u2500 logs/           # Node logs\n\u251c\u2500\u2500 peers/          # Peer information\n\u2514\u2500\u2500 metadata/       # Node metadata\n</code></pre>"},{"location":"api/ant-node/configuration/#environment-variables","title":"Environment Variables","text":"<p>The node configuration can also be set using environment variables:</p> <pre><code># Network settings\nexport ANT_NODE_IP=\"0.0.0.0\"\nexport ANT_NODE_PORT=\"12000\"\nexport ANT_NODE_EVM_NETWORK=\"arbitrum_sepolia\"\nexport ANT_NODE_REWARDS_ADDRESS=\"0x...\"\n\n# Node settings\nexport ANT_NODE_LOCAL=\"false\"\nexport ANT_NODE_HOME_NETWORK=\"false\"\nexport ANT_NODE_ROOT_DIR=\"/path/to/data\"\n\n# Storage settings\nexport ANT_NODE_MAX_STORAGE=\"1073741824\"  # 1GB\nexport ANT_NODE_MIN_FREE_SPACE=\"1048576\"  # 1MB\nexport ANT_NODE_CLEANUP_INTERVAL=\"3600\"\n</code></pre>"},{"location":"api/ant-node/configuration/#configuration-file","title":"Configuration File","text":"<p>You can also provide configuration through a YAML file:</p> <pre><code># config.yaml\nnetwork:\n  ip: \"0.0.0.0\"\n  port: 12000\n  evm_network: \"arbitrum_sepolia\"\n  rewards_address: \"0x...\"\n  initial_peers:\n    - \"/ip4/142.93.37.4/udp/40184/quic-v1/p2p/12D3KooWPC8q7QGZsmuTtCYxZ2s3FPXPZcS8LVKkayXkVFkqDEQB\"\n\nnode:\n  local: false\n  home_network: false\n  root_dir: \"/path/to/data\"\n\nstorage:\n  max_size: 1073741824  # 1GB\n  min_free_space: 1048576  # 1MB\n  cleanup_interval: 3600\n  backup:\n    enabled: true\n    interval: 86400\n    path: \"/path/to/backups\"\n</code></pre> <p>Load the configuration file:</p> PythonRust <pre><code>from antnode import load_config\n\nconfig = load_config(\"config.yaml\")\nnode = AntNode(config)\n</code></pre> <pre><code>use ant_node::config::load_config;\n\nlet config = load_config(\"config.yaml\")?;\nlet node = Node::new(config)?;\n</code></pre>"},{"location":"api/ant-node/configuration/#best-practices","title":"Best Practices","text":"<ol> <li>Network Settings</li> <li>Use a static IP if possible</li> <li>Open required ports in firewall</li> <li> <p>Configure proper rewards address</p> </li> <li> <p>Storage Management</p> </li> <li>Set appropriate storage limits</li> <li>Enable regular backups</li> <li> <p>Monitor free space</p> </li> <li> <p>Security</p> </li> <li>Run node with minimal privileges</li> <li>Secure rewards address private key</li> <li> <p>Regular security updates</p> </li> <li> <p>Monitoring</p> </li> <li>Enable logging</li> <li>Monitor node health</li> <li>Set up alerts</li> </ol>"},{"location":"api/ant-node/network/","title":"Network Operations","text":"<p>This page documents the network operations available in the Ant Node API.</p>"},{"location":"api/ant-node/network/#node-management","title":"Node Management","text":""},{"location":"api/ant-node/network/#starting-a-node","title":"Starting a Node","text":"PythonRust <pre><code>from antnode import AntNode\n\n# Create and start a node\nnode = AntNode()\nnode.run(\n    rewards_address=\"0x1234567890123456789012345678901234567890\",\n    evm_network=\"arbitrum_sepolia\",\n    ip=\"0.0.0.0\",\n    port=12000,\n    initial_peers=[\n        \"/ip4/142.93.37.4/udp/40184/quic-v1/p2p/12D3KooWPC8q7QGZsmuTtCYxZ2s3FPXPZcS8LVKkayXkVFkqDEQB\",\n    ]\n)\n</code></pre> <pre><code>use ant_node::{Node, NodeConfig};\n\n// Create and start a node\nlet config = NodeConfig::default();\nlet mut node = Node::new(config)?;\nnode.run().await?;\n</code></pre>"},{"location":"api/ant-node/network/#node-information","title":"Node Information","text":"PythonRust <pre><code># Get node's peer ID\npeer_id = node.peer_id()\n\n# Get current rewards address\naddress = node.get_rewards_address()\n\n# Get routing table information\nkbuckets = node.get_kbuckets()\nfor distance, peers in kbuckets:\n    print(f\"Distance {distance}: {len(peers)} peers\")\n\n# Get all stored record addresses\nrecords = node.get_all_record_addresses()\n</code></pre> <pre><code>// Get node's peer ID\nlet peer_id = node.peer_id();\n\n// Get current rewards address\nlet address = node.rewards_address();\n\n// Get routing table information\nlet kbuckets = node.get_kbuckets()?;\nfor (distance, peers) in kbuckets {\n    println!(\"Distance {}: {} peers\", distance, peers.len());\n}\n\n// Get all stored record addresses\nlet records = node.get_all_record_addresses()?;\n</code></pre>"},{"location":"api/ant-node/network/#network-events","title":"Network Events","text":""},{"location":"api/ant-node/network/#event-handling","title":"Event Handling","text":"PythonRust <pre><code>from antnode import NodeEvent\n\n# Register event handlers\n@node.on(NodeEvent.CONNECTED)\ndef handle_connected():\n    print(\"Connected to network\")\n\n@node.on(NodeEvent.CHUNK_STORED)\ndef handle_chunk_stored(address):\n    print(f\"Chunk stored: {address}\")\n\n@node.on(NodeEvent.REWARD_RECEIVED)\ndef handle_reward(amount, address):\n    print(f\"Reward received: {amount} at {address}\")\n</code></pre> <pre><code>use ant_node::{NodeEvent, NodeEventsReceiver};\n\n// Get event receiver\nlet mut events: NodeEventsReceiver = node.event_receiver();\n\n// Handle events\nwhile let Ok(event) = events.recv().await {\n    match event {\n        NodeEvent::ConnectedToNetwork =&gt; println!(\"Connected to network\"),\n        NodeEvent::ChunkStored(addr) =&gt; println!(\"Chunk stored: {}\", addr),\n        NodeEvent::RewardReceived(amount, addr) =&gt; {\n            println!(\"Reward received: {} at {}\", amount, addr)\n        }\n        NodeEvent::ChannelClosed =&gt; break,\n        NodeEvent::TerminateNode(reason) =&gt; {\n            println!(\"Node terminated: {}\", reason);\n            break;\n        }\n    }\n}\n</code></pre>"},{"location":"api/ant-node/network/#peer-management","title":"Peer Management","text":""},{"location":"api/ant-node/network/#peer-discovery","title":"Peer Discovery","text":"PythonRust <pre><code># Add a peer manually\nnode.add_peer(\"/ip4/1.2.3.4/udp/12000/quic-v1/p2p/...\")\n\n# Get connected peers\npeers = node.get_connected_peers()\nfor peer in peers:\n    print(f\"Peer: {peer.id}, Address: {peer.address}\")\n\n# Find peers near an address\nnearby = node.find_peers_near(target_address)\n</code></pre> <pre><code>// Add a peer manually\nnode.add_peer(\"/ip4/1.2.3.4/udp/12000/quic-v1/p2p/...\".parse()?)?;\n\n// Get connected peers\nlet peers = node.get_connected_peers()?;\nfor peer in peers {\n    println!(\"Peer: {}, Address: {}\", peer.id, peer.address);\n}\n\n// Find peers near an address\nlet nearby = node.find_peers_near(&amp;target_address).await?;\n</code></pre>"},{"location":"api/ant-node/network/#data-storage","title":"Data Storage","text":""},{"location":"api/ant-node/network/#record-management","title":"Record Management","text":"PythonRust <pre><code># Store a record\nkey = \"0123456789abcdef\"  # Hex string\nvalue = b\"Hello, World!\"\nnode.store_record(key, value, \"chunk\")\n\n# Retrieve a record\ndata = node.get_record(key)\n\n# Delete a record\nsuccess = node.delete_record(key)\n\n# Get total storage size\nsize = node.get_stored_records_size()\n</code></pre> <pre><code>use ant_node::storage::ValidationType;\n\n// Store a record\nlet key = \"0123456789abcdef\";  // Hex string\nlet value = b\"Hello, World!\";\nnode.store_record(key, value, ValidationType::Chunk)?;\n\n// Retrieve a record\nlet data = node.get_record(key)?;\n\n// Delete a record\nlet success = node.delete_record(key)?;\n\n// Get total storage size\nlet size = node.get_stored_records_size()?;\n</code></pre>"},{"location":"api/ant-node/network/#network-metrics","title":"Network Metrics","text":""},{"location":"api/ant-node/network/#performance-monitoring","title":"Performance Monitoring","text":"PythonRust <pre><code># Get network metrics\nmetrics = node.get_metrics()\nprint(f\"Connected peers: {metrics.peer_count}\")\nprint(f\"Records stored: {metrics.record_count}\")\nprint(f\"Storage used: {metrics.storage_used}\")\nprint(f\"Bandwidth in: {metrics.bandwidth_in}\")\nprint(f\"Bandwidth out: {metrics.bandwidth_out}\")\n\n# Get node uptime\nuptime = node.get_uptime()\nprint(f\"Node uptime: {uptime} seconds\")\n</code></pre> <pre><code>// Get network metrics\nlet metrics = node.get_metrics()?;\nprintln!(\"Connected peers: {}\", metrics.peer_count);\nprintln!(\"Records stored: {}\", metrics.record_count);\nprintln!(\"Storage used: {}\", metrics.storage_used);\nprintln!(\"Bandwidth in: {}\", metrics.bandwidth_in);\nprintln!(\"Bandwidth out: {}\", metrics.bandwidth_out);\n\n// Get node uptime\nlet uptime = node.get_uptime()?;\nprintln!(\"Node uptime: {} seconds\", uptime);\n</code></pre>"},{"location":"api/ant-node/network/#best-practices","title":"Best Practices","text":"<ol> <li>Event Handling</li> <li>Always handle critical events</li> <li>Implement proper error recovery</li> <li> <p>Log important events</p> </li> <li> <p>Peer Management</p> </li> <li>Maintain healthy peer connections</li> <li>Implement peer discovery</li> <li> <p>Handle peer disconnections</p> </li> <li> <p>Storage Management</p> </li> <li>Monitor storage usage</li> <li>Implement cleanup policies</li> <li> <p>Handle storage full conditions</p> </li> <li> <p>Network Health</p> </li> <li>Monitor network metrics</li> <li>Track bandwidth usage</li> <li>Monitor node performance</li> </ol>"},{"location":"api/autonomi-client/","title":"Autonomi API Documentation","text":""},{"location":"api/autonomi-client/#installation","title":"Installation","text":"<p>Choose your preferred language:</p> Node.jsPythonRust <pre><code># Note: Package not yet published to npm\n# Clone the repository and build from source\ngit clone https://github.com/dirvine/autonomi.git\ncd autonomi\nnpm install\n</code></pre> <pre><code>pip install autonomi\n</code></pre> <pre><code># Add to Cargo.toml:\n[dependencies]\nautonomi = \"0.3.1\"\n</code></pre>"},{"location":"api/autonomi-client/#client-initialization","title":"Client Initialization","text":"<p>Initialize a client in read-only mode for browsing data, or with write capabilities for full access:</p> Node.jsPythonRust <pre><code>import { Client } from 'autonomi';\n\n// Initialize a read-only client\nconst client = await Client.initReadOnly();\n\n// Or initialize with write capabilities and configuration\nconst config = {\n    // Add your configuration here\n};\nconst client = await Client.initWithConfig(config);\n</code></pre> <pre><code>from autonomi import Client\n\n# Initialize a read-only client\nclient = Client.init_read_only()\n\n# Or initialize with write capabilities and configuration\nconfig = {\n    # Add your configuration here\n}\nclient = Client.init_with_config(config)\n</code></pre> <pre><code>use autonomi::Client;\n\n// Initialize a read-only client\nlet client = Client::new_local().await?;\n\n// Or initialize with configuration\nlet config = ClientConfig::default();\nlet client = Client::new(config).await?;\n</code></pre>"},{"location":"api/autonomi-client/#core-data-types","title":"Core Data Types","text":"<p>Autonomi provides four fundamental data types that serve as building blocks for all network operations. For detailed information about each type, see the Data Types Guide.</p>"},{"location":"api/autonomi-client/#1-chunk","title":"1. Chunk","text":"<p>Immutable, quantum-secure encrypted data blocks:</p> Node.jsPythonRust <pre><code>import { Chunk } from 'autonomi';\n\n// Store raw data as a chunk\nconst data = Buffer.from('Hello, World!');\nconst chunk = await client.storeChunk(data);\n\n// Retrieve chunk data\nconst retrieved = await client.getChunk(chunk.address);\nassert(Buffer.compare(data, retrieved) === 0);\n\n// Get chunk metadata\nconst metadata = await client.getChunkMetadata(chunk.address);\nconsole.log(`Size: ${metadata.size}`);\n</code></pre> <pre><code>from autonomi import Chunk\n\n# Store raw data as a chunk\ndata = b\"Hello, World!\"\nchunk = client.store_chunk(data)\n\n# Retrieve chunk data\nretrieved = client.get_chunk(chunk.address)\nassert data == retrieved\n\n# Get chunk metadata\nmetadata = client.get_chunk_metadata(chunk.address)\nprint(f\"Size: {metadata.size}\")\n</code></pre> <pre><code>use autonomi::Chunk;\n\n// Store raw data as a chunk\nlet data = b\"Hello, World!\";\nlet chunk = client.store_chunk(data).await?;\n\n// Retrieve chunk data\nlet retrieved = client.get_chunk(chunk.address()).await?;\nassert_eq!(data, &amp;retrieved[..]);\n\n// Get chunk metadata\nlet metadata = client.get_chunk_metadata(chunk.address()).await?;\nprintln!(\"Size: {}\", metadata.size);\n</code></pre>"},{"location":"api/autonomi-client/#2-pointer","title":"2. Pointer","text":"<p>Mutable references with version tracking:</p> Node.jsPythonRust <pre><code>import { Pointer } from 'autonomi';\n\n// Create a pointer to some data\nconst pointer = await client.createPointer(targetAddress);\n\n// Update pointer target\nawait client.updatePointer(pointer.address, newTargetAddress);\n\n// Resolve pointer to get current target\nconst target = await client.resolvePointer(pointer.address);\n\n// Get pointer metadata and version\nconst metadata = await client.getPointerMetadata(pointer.address);\nconsole.log(`Version: ${metadata.version}`);\n</code></pre> <pre><code>from autonomi import Pointer\n\n# Create a pointer to some data\npointer = client.create_pointer(target_address)\n\n# Update pointer target\nclient.update_pointer(pointer.address, new_target_address)\n\n# Resolve pointer to get current target\ntarget = client.resolve_pointer(pointer.address)\n\n# Get pointer metadata and version\nmetadata = client.get_pointer_metadata(pointer.address)\nprint(f\"Version: {metadata.version}\")\n</code></pre> <pre><code>use autonomi::Pointer;\n\n// Create a pointer to some data\nlet pointer = client.create_pointer(target_address).await?;\n\n// Update pointer target\nclient.update_pointer(pointer.address(), new_target_address).await?;\n\n// Resolve pointer to get current target\nlet target = client.resolve_pointer(pointer.address()).await?;\n\n// Get pointer metadata and version\nlet metadata = client.get_pointer_metadata(pointer.address()).await?;\nprintln!(\"Version: {}\", metadata.version);\n</code></pre>"},{"location":"api/autonomi-client/#3-linkedlist","title":"3. LinkedList","text":"<p>Decentralized DAG structures for transaction chains:</p> Node.jsPythonRust <pre><code>import { LinkedList } from 'autonomi';\n\n// Create a new linked list\nconst list = await client.createLinkedList();\n\n// Append items\nawait client.appendToList(list.address, item1);\nawait client.appendToList(list.address, item2);\n\n// Read list contents\nconst items = await client.getList(list.address);\n\n// Get list history\nconst history = await client.getListHistory(list.address);\nfor (const entry of history) {\n    console.log(`Version ${entry.version}: ${entry.data}`);\n}\n\n// Check for forks\nconst forks = await client.detectForks(list.address);\nif (!forks) {\n    console.log('No forks detected');\n} else {\n    handleForks(forks.branches);\n}\n</code></pre> <pre><code>from autonomi import LinkedList\n\n# Create a new linked list\nlist = client.create_linked_list()\n\n# Append items\nclient.append_to_list(list.address, item1)\nclient.append_to_list(list.address, item2)\n\n# Read list contents\nitems = client.get_list(list.address)\n\n# Get list history\nhistory = client.get_list_history(list.address)\nfor entry in history:\n    print(f\"Version {entry.version}: {entry.data}\")\n\n# Check for forks\nforks = client.detect_forks(list.address)\nif not forks:\n    print(\"No forks detected\")\nelse:\n    handle_forks(forks.branches)\n</code></pre> <pre><code>use autonomi::LinkedList;\n\n// Create a new linked list\nlet list = client.create_linked_list().await?;\n\n// Append items\nclient.append_to_list(list.address(), item1).await?;\nclient.append_to_list(list.address(), item2).await?;\n\n// Read list contents\nlet items = client.get_list(list.address()).await?;\n\n// Get list history\nlet history = client.get_list_history(list.address()).await?;\nfor entry in history {\n    println!(\"Version {}: {:?}\", entry.version, entry.data);\n}\n\n// Check for forks\nlet forks = client.detect_forks(list.address()).await?;\nmatch forks {\n    Fork::None =&gt; println!(\"No forks detected\"),\n    Fork::Detected(branches) =&gt; handle_forks(branches),\n}\n</code></pre>"},{"location":"api/autonomi-client/#4-scratchpad","title":"4. ScratchPad","text":"<p>Unstructured data with CRDT properties:</p> Node.jsPythonRust <pre><code>import { ScratchPad, ContentType } from 'autonomi';\n\n// Create a scratchpad\nconst pad = await client.createScratchpad(ContentType.UserSettings);\n\n// Update with data\nawait client.updateScratchpad(pad.address, settingsData);\n\n// Read current data\nconst current = await client.getScratchpad(pad.address);\n\n// Get metadata\nconst metadata = await client.getScratchpadMetadata(pad.address);\nconsole.log(`Updates: ${metadata.updateCounter}`);\n</code></pre> <pre><code>from autonomi import ScratchPad, ContentType\n\n# Create a scratchpad\npad = client.create_scratchpad(ContentType.USER_SETTINGS)\n\n# Update with data\nclient.update_scratchpad(pad.address, settings_data)\n\n# Read current data\ncurrent = client.get_scratchpad(pad.address)\n\n# Get metadata\nmetadata = client.get_scratchpad_metadata(pad.address)\nprint(f\"Updates: {metadata.update_counter}\")\n</code></pre> <pre><code>use autonomi::{ScratchPad, ContentType};\n\n// Create a scratchpad\nlet pad = client.create_scratchpad(ContentType::UserSettings).await?;\n\n// Update with data\nclient.update_scratchpad(pad.address(), settings_data).await?;\n\n// Read current data\nlet current = client.get_scratchpad(pad.address()).await?;\n\n// Get metadata\nlet metadata = client.get_scratchpad_metadata(pad.address()).await?;\nprintln!(\"Updates: {}\", metadata.update_counter);\n</code></pre>"},{"location":"api/autonomi-client/#file-system-operations","title":"File System Operations","text":"<p>Create and manage files and directories:</p> Node.jsPythonRust <pre><code>import { File, Directory } from 'autonomi/fs';\n\n// Store a file\nconst file = await client.storeFile('example.txt', content);\n\n// Create a directory\nconst dir = await client.createDirectory('docs');\n\n// Add file to directory\nawait client.addToDirectory(dir.address, file.address);\n\n// List directory contents\nconst entries = await client.listDirectory(dir.address);\nfor (const entry of entries) {\n    if (entry.isFile) {\n        console.log(`File: ${entry.name}`);\n    } else {\n        console.log(`Dir: ${entry.name}`);\n    }\n}\n</code></pre> <pre><code>from autonomi.fs import File, Directory\n\n# Store a file\nfile = client.store_file(\"example.txt\", content)\n\n# Create a directory\ndir = client.create_directory(\"docs\")\n\n# Add file to directory\nclient.add_to_directory(dir.address, file.address)\n\n# List directory contents\nentries = client.list_directory(dir.address)\nfor entry in entries:\n    if entry.is_file:\n        print(f\"File: {entry.name}\")\n    else:\n        print(f\"Dir: {entry.name}\")\n</code></pre> <pre><code>use autonomi::fs::{File, Directory};\n\n// Store a file\nlet file = client.store_file(\"example.txt\", content).await?;\n\n// Create a directory\nlet dir = client.create_directory(\"docs\").await?;\n\n// Add file to directory\nclient.add_to_directory(dir.address(), file.address()).await?;\n\n// List directory contents\nlet entries = client.list_directory(dir.address()).await?;\nfor entry in entries {\n    match entry {\n        DirEntry::File(f) =&gt; println!(\"File: {}\", f.name),\n        DirEntry::Directory(d) =&gt; println!(\"Dir: {}\", d.name),\n    }\n}\n</code></pre>"},{"location":"api/autonomi-client/#error-handling","title":"Error Handling","text":"<p>Each language provides appropriate error handling mechanisms:</p> Node.jsPythonRust <pre><code>import { ChunkError, PointerError } from 'autonomi/errors';\n\n// Handle chunk operations\ntry {\n    const data = await client.getChunk(address);\n    processData(data);\n} catch (error) {\n    if (error instanceof ChunkError.NotFound) {\n        handleMissing();\n    } else if (error instanceof ChunkError.NetworkError) {\n        handleNetworkError(error);\n    } else {\n        handleOtherError(error);\n    }\n}\n\n// Handle pointer updates\ntry {\n    await client.updatePointer(address, newTarget);\n    console.log('Update successful');\n} catch (error) {\n    if (error instanceof PointerError.VersionConflict) {\n        handleConflict();\n    } else {\n        handleOtherError(error);\n    }\n}\n</code></pre> <pre><code>from autonomi.errors import ChunkError, PointerError\n\n# Handle chunk operations\ntry:\n    data = client.get_chunk(address)\n    process_data(data)\nexcept ChunkError.NotFound:\n    handle_missing()\nexcept ChunkError.NetworkError as e:\n    handle_network_error(e)\nexcept Exception as e:\n    handle_other_error(e)\n\n# Handle pointer updates\ntry:\n    client.update_pointer(address, new_target)\n    print(\"Update successful\")\nexcept PointerError.VersionConflict:\n    handle_conflict()\nexcept Exception as e:\n    handle_other_error(e)\n</code></pre> <pre><code>use autonomi::error::{ChunkError, PointerError, ListError, ScratchPadError};\n\n// Handle chunk operations\nmatch client.get_chunk(address).await {\n    Ok(data) =&gt; process_data(data),\n    Err(ChunkError::NotFound) =&gt; handle_missing(),\n    Err(ChunkError::NetworkError(e)) =&gt; handle_network_error(e),\n    Err(e) =&gt; handle_other_error(e),\n}\n\n// Handle pointer updates\nmatch client.update_pointer(address, new_target).await {\n    Ok(_) =&gt; println!(\"Update successful\"),\n    Err(PointerError::VersionConflict) =&gt; handle_conflict(),\n    Err(e) =&gt; handle_other_error(e),\n}\n</code></pre>"},{"location":"api/autonomi-client/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/autonomi-client/#custom-types","title":"Custom Types","text":"Node.jsPythonRust <pre><code>interface MyData {\n    field1: string;\n    field2: number;\n}\n\n// Store custom type in a scratchpad\nconst data: MyData = {\n    field1: 'test',\n    field2: 42\n};\nconst pad = await client.createScratchpad(ContentType.Custom('MyData'));\nawait client.updateScratchpad(pad.address, data);\n</code></pre> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass MyData:\n    field1: str\n    field2: int\n\n# Store custom type in a scratchpad\ndata = MyData(field1=\"test\", field2=42)\npad = client.create_scratchpad(ContentType.CUSTOM(\"MyData\"))\nclient.update_scratchpad(pad.address, data)\n</code></pre> <pre><code>use serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize)]\nstruct MyData {\n    field1: String,\n    field2: u64,\n}\n\n// Store custom type in a scratchpad\nlet data = MyData {\n    field1: \"test\".into(),\n    field2: 42,\n};\nlet pad = client.create_scratchpad(ContentType::Custom(\"MyData\")).await?;\nclient.update_scratchpad(pad.address(), &amp;data).await?;\n</code></pre>"},{"location":"api/autonomi-client/#encryption","title":"Encryption","text":"Node.jsPythonRust <pre><code>import { encrypt, decrypt, generateKey } from 'autonomi/crypto';\n\n// Encrypt data before storage\nconst key = await generateAesKey();\nconst encrypted = await encryptAes(data, key);\nconst pad = await client.createScratchpad(ContentType.Encrypted);\nawait client.updateScratchpad(pad.address, encrypted);\n\n// Decrypt retrieved data\nconst encrypted = await client.getScratchpad(pad.address);\nconst decrypted = await decryptAes(encrypted, key);\n</code></pre> <pre><code>from autonomi.crypto import encrypt_aes, decrypt_aes\n\n# Encrypt data before storage\nkey = generate_aes_key()\nencrypted = encrypt_aes(data, key)\npad = client.create_scratchpad(ContentType.ENCRYPTED)\nclient.update_scratchpad(pad.address, encrypted)\n\n# Decrypt retrieved data\nencrypted = client.get_scratchpad(pad.address)\ndecrypted = decrypt_aes(encrypted, key)\n</code></pre> <pre><code>use autonomi::crypto::{encrypt_aes, decrypt_aes};\n\n// Encrypt data before storage\nlet key = generate_aes_key();\nlet encrypted = encrypt_aes(data, &amp;key)?;\nlet pad = client.create_scratchpad(ContentType::Encrypted).await?;\nclient.update_scratchpad(pad.address(), &amp;encrypted).await?;\n\n// Decrypt retrieved data\nlet encrypted = client.get_scratchpad(pad.address()).await?;\nlet decrypted = decrypt_aes(encrypted, &amp;key)?;\n</code></pre>"},{"location":"api/autonomi-client/#best-practices","title":"Best Practices","text":"<ol> <li>Data Type Selection</li> <li>Use Chunks for immutable data</li> <li>Use Pointers for mutable references</li> <li>Use LinkedLists for ordered collections</li> <li> <p>Use ScratchPads for temporary data</p> </li> <li> <p>Error Handling</p> </li> <li>Always handle network errors appropriately</li> <li>Use type-specific error handling</li> <li> <p>Implement retry logic for transient failures</p> </li> <li> <p>Performance</p> </li> <li>Use batch operations for multiple items</li> <li>Consider chunking large data sets</li> <li> <p>Cache frequently accessed data locally</p> </li> <li> <p>Security</p> </li> <li>Encrypt sensitive data before storage</li> <li>Use secure key management</li> <li>Validate data integrity</li> </ol>"},{"location":"api/autonomi-client/#type-system","title":"Type System","text":"Node.jsPythonRust <pre><code>import { Address, Data, Metadata } from 'autonomi/types';\n\ninterface Client {\n    storeChunk(data: Buffer): Promise&lt;Address&gt;;\n    getChunk(address: Address): Promise&lt;Buffer&gt;;\n    createPointer(target: Address): Promise&lt;Pointer&gt;;\n    updatePointer(address: Address, target: Address): Promise&lt;void&gt;;\n}\n</code></pre> <pre><code>from typing import List, Optional, Union\nfrom autonomi.types import Address, Data, Metadata\n\nclass Client:\n    def store_chunk(self, data: bytes) -&gt; Address: ...\n    def get_chunk(self, address: Address) -&gt; bytes: ...\n    def create_pointer(self, target: Address) -&gt; Pointer: ...\n    def update_pointer(self, address: Address, target: Address) -&gt; None: ...\n</code></pre> <pre><code>use autonomi::types::{Address, Data, Metadata};\n\npub trait Client {\n    async fn store_chunk(&amp;self, data: &amp;[u8]) -&gt; Result&lt;Address&gt;;\n    async fn get_chunk(&amp;self, address: &amp;Address) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;\n    async fn create_pointer(&amp;self, target: Address) -&gt; Result&lt;Pointer&gt;;\n    async fn update_pointer(&amp;self, address: Address, target: Address) -&gt; Result&lt;()&gt;;\n}\n</code></pre>"},{"location":"api/autonomi-client/#further-reading","title":"Further Reading","text":"<ul> <li>Data Types Guide</li> <li>Client Modes Guide</li> <li>Local Network Setup</li> </ul>"},{"location":"api/autonomi-client/data_types/","title":"Data Types Reference","text":"<p>This page provides detailed information about the core data types used in the Autonomi Client API.</p>"},{"location":"api/autonomi-client/data_types/#address","title":"Address","text":"<p>A unique identifier for content in the network.</p> Node.jsPythonRust <pre><code>interface Address {\n    readonly bytes: Buffer;\n    toString(): string;\n    equals(other: Address): boolean;\n}\n</code></pre> <pre><code>class Address:\n    @property\n    def bytes(self) -&gt; bytes: ...\n    def __str__(self) -&gt; str: ...\n    def __eq__(self, other: Address) -&gt; bool: ...\n</code></pre> <pre><code>pub struct Address([u8; 32]);\n\nimpl Address {\n    pub fn as_bytes(&amp;self) -&gt; &amp;[u8];\n    pub fn to_string(&amp;self) -&gt; String;\n}\n</code></pre>"},{"location":"api/autonomi-client/data_types/#chunk","title":"Chunk","text":"<p>An immutable data block with quantum-secure encryption.</p> Node.jsPythonRust <pre><code>interface Chunk {\n    readonly address: Address;\n    readonly data: Buffer;\n    readonly size: number;\n    readonly type: ChunkType;\n}\n\nenum ChunkType {\n    Data,\n    Metadata,\n    Index\n}\n</code></pre> <pre><code>class Chunk:\n    @property\n    def address(self) -&gt; Address: ...\n    @property\n    def data(self) -&gt; bytes: ...\n    @property\n    def size(self) -&gt; int: ...\n    @property\n    def type(self) -&gt; ChunkType: ...\n\nclass ChunkType(Enum):\n    DATA = 1\n    METADATA = 2\n    INDEX = 3\n</code></pre> <pre><code>pub struct Chunk {\n    pub address: Address,\n    pub data: Vec&lt;u8&gt;,\n    pub size: usize,\n    pub type_: ChunkType,\n}\n\npub enum ChunkType {\n    Data,\n    Metadata,\n    Index,\n}\n</code></pre>"},{"location":"api/autonomi-client/data_types/#pointer","title":"Pointer","text":"<p>A mutable reference to data in the network.</p> Node.jsPythonRust <pre><code>interface Pointer {\n    readonly address: Address;\n    readonly target: Address;\n    readonly version: number;\n    setTarget(target: Address): void;\n}\n</code></pre> <pre><code>class Pointer:\n    @property\n    def address(self) -&gt; Address: ...\n    @property\n    def target(self) -&gt; Address: ...\n    @property\n    def version(self) -&gt; int: ...\n    def set_target(self, target: Address) -&gt; None: ...\n</code></pre> <pre><code>pub struct Pointer {\n    pub address: Address,\n    pub target: Address,\n    pub version: u64,\n}\n\nimpl Pointer {\n    pub fn set_target(&amp;mut self, target: Address);\n}\n</code></pre>"},{"location":"api/autonomi-client/data_types/#linkedlist","title":"LinkedList","text":"<p>A decentralized DAG structure for ordered data.</p> Node.jsPythonRust <pre><code>interface LinkedList&lt;T&gt; {\n    readonly address: Address;\n    readonly length: number;\n    append(item: T): void;\n    get(index: number): T;\n    toArray(): T[];\n}\n</code></pre> <pre><code>class LinkedList(Generic[T]):\n    @property\n    def address(self) -&gt; Address: ...\n    @property\n    def length(self) -&gt; int: ...\n    def append(self, item: T) -&gt; None: ...\n    def __getitem__(self, index: int) -&gt; T: ...\n    def to_list(self) -&gt; List[T]: ...\n</code></pre> <pre><code>pub struct LinkedList&lt;T&gt; {\n    pub address: Address,\n    pub length: usize,\n}\n\nimpl&lt;T&gt; LinkedList&lt;T&gt; {\n    pub fn append(&amp;mut self, item: T);\n    pub fn get(&amp;self, index: usize) -&gt; Option&lt;&amp;T&gt;;\n    pub fn to_vec(&amp;self) -&gt; Vec&lt;T&gt;;\n}\n</code></pre>"},{"location":"api/autonomi-client/data_types/#scratchpad","title":"ScratchPad","text":"<p>Unstructured data with CRDT properties.</p> Node.jsPythonRust <pre><code>interface ScratchPad {\n    readonly address: Address;\n    readonly type: ContentType;\n    readonly updateCounter: number;\n    update(data: Buffer): void;\n    getData(): Buffer;\n}\n</code></pre> <pre><code>class ScratchPad:\n    @property\n    def address(self) -&gt; Address: ...\n    @property\n    def type(self) -&gt; ContentType: ...\n    @property\n    def update_counter(self) -&gt; int: ...\n    def update(self, data: bytes) -&gt; None: ...\n    def get_data(self) -&gt; bytes: ...\n</code></pre> <pre><code>pub struct ScratchPad {\n    pub address: Address,\n    pub type_: ContentType,\n    pub update_counter: u64,\n}\n\nimpl ScratchPad {\n    pub fn update(&amp;mut self, data: Vec&lt;u8&gt;);\n    pub fn get_data(&amp;self) -&gt; Vec&lt;u8&gt;;\n}\n</code></pre>"},{"location":"api/autonomi-client/errors/","title":"Error Handling Reference","text":"<p>This page documents the error types and handling patterns for the Autonomi Client API.</p>"},{"location":"api/autonomi-client/errors/#error-types","title":"Error Types","text":""},{"location":"api/autonomi-client/errors/#chunkerror","title":"ChunkError","text":"<p>Errors related to chunk operations.</p> Node.jsPythonRust <pre><code>class ChunkError extends Error {\n    static NotFound: typeof ChunkError;\n    static InvalidSize: typeof ChunkError;\n    static NetworkError: typeof ChunkError;\n    static StorageFull: typeof ChunkError;\n}\n\ntry {\n    const chunk = await client.getChunk(address);\n} catch (error) {\n    if (error instanceof ChunkError.NotFound) {\n        // Handle missing chunk\n    } else if (error instanceof ChunkError.NetworkError) {\n        // Handle network issues\n    }\n}\n</code></pre> <pre><code>class ChunkError(Exception):\n    class NotFound(ChunkError): pass\n    class InvalidSize(ChunkError): pass\n    class NetworkError(ChunkError): pass\n    class StorageFull(ChunkError): pass\n\ntry:\n    chunk = client.get_chunk(address)\nexcept ChunkError.NotFound:\n    # Handle missing chunk\n    pass\nexcept ChunkError.NetworkError as e:\n    # Handle network issues\n    pass\n</code></pre> <pre><code>pub enum ChunkError {\n    NotFound,\n    InvalidSize,\n    NetworkError(NetworkError),\n    StorageFull,\n}\n\nmatch client.get_chunk(address).await {\n    Ok(chunk) =&gt; { /* Process chunk */ }\n    Err(ChunkError::NotFound) =&gt; { /* Handle missing chunk */ }\n    Err(ChunkError::NetworkError(e)) =&gt; { /* Handle network issues */ }\n    Err(e) =&gt; { /* Handle other errors */ }\n}\n</code></pre>"},{"location":"api/autonomi-client/errors/#pointererror","title":"PointerError","text":"<p>Errors related to pointer operations.</p> Node.jsPythonRust <pre><code>class PointerError extends Error {\n    static NotFound: typeof PointerError;\n    static VersionConflict: typeof PointerError;\n    static InvalidTarget: typeof PointerError;\n}\n\ntry {\n    await client.updatePointer(address, newTarget);\n} catch (error) {\n    if (error instanceof PointerError.VersionConflict) {\n        // Handle version conflict\n    }\n}\n</code></pre> <pre><code>class PointerError(Exception):\n    class NotFound(PointerError): pass\n    class VersionConflict(PointerError): pass\n    class InvalidTarget(PointerError): pass\n\ntry:\n    client.update_pointer(address, new_target)\nexcept PointerError.VersionConflict:\n    # Handle version conflict\n    pass\n</code></pre> <pre><code>pub enum PointerError {\n    NotFound,\n    VersionConflict,\n    InvalidTarget,\n}\n\nmatch client.update_pointer(address, new_target).await {\n    Ok(_) =&gt; { /* Success */ }\n    Err(PointerError::VersionConflict) =&gt; { /* Handle conflict */ }\n    Err(e) =&gt; { /* Handle other errors */ }\n}\n</code></pre>"},{"location":"api/autonomi-client/errors/#listerror","title":"ListError","text":"<p>Errors related to linked list operations.</p> Node.jsPythonRust <pre><code>class ListError extends Error {\n    static NotFound: typeof ListError;\n    static InvalidIndex: typeof ListError;\n    static ForkDetected: typeof ListError;\n}\n\ntry {\n    const item = await client.getListItem(address, index);\n} catch (error) {\n    if (error instanceof ListError.InvalidIndex) {\n        // Handle invalid index\n    }\n}\n</code></pre> <pre><code>class ListError(Exception):\n    class NotFound(ListError): pass\n    class InvalidIndex(ListError): pass\n    class ForkDetected(ListError): pass\n\ntry:\n    item = client.get_list_item(address, index)\nexcept ListError.InvalidIndex:\n    # Handle invalid index\n    pass\n</code></pre> <pre><code>pub enum ListError {\n    NotFound,\n    InvalidIndex,\n    ForkDetected,\n}\n\nmatch client.get_list_item(address, index).await {\n    Ok(item) =&gt; { /* Process item */ }\n    Err(ListError::InvalidIndex) =&gt; { /* Handle invalid index */ }\n    Err(e) =&gt; { /* Handle other errors */ }\n}\n</code></pre>"},{"location":"api/autonomi-client/errors/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"api/autonomi-client/errors/#retry-logic","title":"Retry Logic","text":"<p>For transient errors like network issues:</p> Node.jsPythonRust <pre><code>async function withRetry&lt;T&gt;(\n    operation: () =&gt; Promise&lt;T&gt;,\n    maxRetries = 3,\n    delay = 1000\n): Promise&lt;T&gt; {\n    let lastError: Error;\n    for (let i = 0; i &lt; maxRetries; i++) {\n        try {\n            return await operation();\n        } catch (error) {\n            if (error instanceof ChunkError.NetworkError) {\n                lastError = error;\n                await new Promise(resolve =&gt; setTimeout(resolve, delay));\n                continue;\n            }\n            throw error;\n        }\n    }\n    throw lastError;\n}\n\n// Usage\nconst chunk = await withRetry(() =&gt; client.getChunk(address));\n</code></pre> <pre><code>async def with_retry(operation, max_retries=3, delay=1.0):\n    last_error = None\n    for i in range(max_retries):\n        try:\n            return await operation()\n        except ChunkError.NetworkError as e:\n            last_error = e\n            await asyncio.sleep(delay)\n            continue\n        except Exception as e:\n            raise e\n    raise last_error\n\n# Usage\nchunk = await with_retry(lambda: client.get_chunk(address))\n</code></pre> <pre><code>async fn with_retry&lt;F, T, E&gt;(\n    operation: F,\n    max_retries: u32,\n    delay: Duration\n) -&gt; Result&lt;T, E&gt;\nwhere\n    F: Fn() -&gt; Future&lt;Output = Result&lt;T, E&gt;&gt;,\n    E: From&lt;ChunkError&gt;,\n{\n    let mut last_error = None;\n    for_ in 0..max_retries {\n        match operation().await {\n            Ok(result) =&gt; return Ok(result),\n            Err(e) =&gt; {\n                if let Some(ChunkError::NetworkError(_)) = e.downcast_ref() {\n                    last_error = Some(e);\n                    tokio::time::sleep(delay).await;\n                    continue;\n                }\n                return Err(e);\n            }\n        }\n    }\n    Err(last_error.unwrap())\n}\n\n// Usage\nlet chunk = with_retry(|| client.get_chunk(address), 3, Duration::from_secs(1)).await?;\n</code></pre>"},{"location":"api/autonomi-client/errors/#error-recovery","title":"Error Recovery","text":"<p>For handling version conflicts in pointers:</p> Node.jsPythonRust <pre><code>async function updatePointerSafely(\n    client: Client,\n    address: Address,\n    newTarget: Address\n): Promise&lt;void&gt; {\n    while (true) {\n        try {\n            await client.updatePointer(address, newTarget);\n            break;\n        } catch (error) {\n            if (error instanceof PointerError.VersionConflict) {\n                const current = await client.resolvePointer(address);\n                if (current.equals(newTarget)) break;\n                continue;\n            }\n            throw error;\n        }\n    }\n}\n</code></pre> <pre><code>async def update_pointer_safely(client, address, new_target):\n    while True:\n        try:\n            await client.update_pointer(address, new_target)\n            break\n        except PointerError.VersionConflict:\n            current = await client.resolve_pointer(address)\n            if current == new_target:\n                break\n            continue\n        except Exception as e:\n            raise e\n</code></pre> <pre><code>async fn update_pointer_safely(\n    client: &amp;Client,\n    address: Address,\n    new_target: Address\n) -&gt; Result&lt;()&gt; {\n    loop {\n        match client.update_pointer(address, new_target).await {\n            Ok(_) =&gt; break Ok(()),\n            Err(PointerError::VersionConflict) =&gt; {\n                let current = client.resolve_pointer(address).await?;\n                if current == new_target {\n                    break Ok(());\n                }\n                continue;\n            }\n            Err(e) =&gt; break Err(e),\n        }\n    }\n}\n</code></pre>"},{"location":"api/blsttc/","title":"BLS Threshold Crypto API Reference","text":"<p>BLS Threshold Crypto (blsttc) is a Rust implementation of BLS (Boneh-Lynn-Shacham) threshold signatures with support for both Rust and Python interfaces.</p>"},{"location":"api/blsttc/#installation","title":"Installation","text":"PythonRust <pre><code># Install using uv (recommended)\ncurl -LsSf &lt;https://astral.sh/uv/install.sh&gt; | sh\nuv pip install blsttc\n\n# Or using pip\npip install blsttc\n</code></pre> <pre><code># Add to Cargo.toml\n[dependencies]\nblsttc = \"8.0.2\"\n</code></pre>"},{"location":"api/blsttc/#basic-usage","title":"Basic Usage","text":"PythonRust <pre><code>from blsttc import SecretKey, PublicKey, Signature\n\n# Generate a secret key\nsecret_key = SecretKey.random()\n\n# Get the corresponding public key\npublic_key = secret_key.public_key()\n\n# Sign a message\nmessage = b\"Hello, World!\"\nsignature = secret_key.sign(message)\n\n# Verify the signature\nassert public_key.verify(signature, message)\n</code></pre> <pre><code>use blsttc::{SecretKey, PublicKey, Signature};\n\n// Generate a secret key\nlet secret_key = SecretKey::random();\n\n// Get the corresponding public key\nlet public_key = secret_key.public_key();\n\n// Sign a message\nlet message = b\"Hello, World!\";\nlet signature = secret_key.sign(message);\n\n// Verify the signature\nassert!(public_key.verify(&amp;signature, message));\n</code></pre>"},{"location":"api/blsttc/#threshold-signatures","title":"Threshold Signatures","text":"PythonRust <pre><code>from blsttc import SecretKeySet, PublicKeySet\n\n# Create a threshold signature scheme\nthreshold = 3  # Minimum signatures required\ntotal = 5      # Total number of shares\nsk_set = SecretKeySet.random(threshold)\n\n# Get the public key set\npk_set = sk_set.public_keys()\n\n# Generate secret key shares\nsecret_shares = [sk_set.secret_key_share(i) for i in range(total)]\n\n# Sign with individual shares\nmessage = b\"Hello, World!\"\nsig_shares = [share.sign(message) for share in secret_shares]\n\n# Combine signatures\ncombined_sig = pk_set.combine_signatures(sig_shares[:threshold])\n\n# Verify the combined signature\nassert pk_set.public_key().verify(combined_sig, message)\n</code></pre> <pre><code>use blsttc::{SecretKeySet, PublicKeySet};\n\n// Create a threshold signature scheme\nlet threshold = 3;  // Minimum signatures required\nlet total = 5;      // Total number of shares\nlet sk_set = SecretKeySet::random(threshold);\n\n// Get the public key set\nlet pk_set = sk_set.public_keys();\n\n// Generate secret key shares\nlet secret_shares: Vec&lt;_&gt; = (0..total)\n    .map(|i| sk_set.secret_key_share(i))\n    .collect();\n\n// Sign with individual shares\nlet message = b\"Hello, World!\";\nlet sig_shares: Vec&lt;_&gt; = secret_shares\n    .iter()\n    .map(|share| share.sign(message))\n    .collect();\n\n// Combine signatures\nlet combined_sig = pk_set.combine_signatures(sig_shares[..threshold].iter())?;\n\n// Verify the combined signature\nassert!(pk_set.public_key().verify(&amp;combined_sig, message));\n</code></pre>"},{"location":"api/blsttc/#advanced-features","title":"Advanced Features","text":""},{"location":"api/blsttc/#key-generation","title":"Key Generation","text":"PythonRust <pre><code>from blsttc import SecretKey, Fr\n\n# Generate from random seed\nsecret_key = SecretKey.random()\n\n# Generate from bytes\nbytes_data = b\"some-32-byte-seed\"\nsecret_key = SecretKey.from_bytes(bytes_data)\n\n# Generate from field element\nfr = Fr.random()\nsecret_key = SecretKey.from_fr(fr)\n</code></pre> <pre><code>use blsttc::{SecretKey, Fr};\nuse rand::thread_rng;\n\n// Generate from random seed\nlet secret_key = SecretKey::random();\n\n// Generate from bytes\nlet bytes_data = b\"some-32-byte-seed\";\nlet secret_key = SecretKey::from_bytes(bytes_data)?;\n\n// Generate from field element\nlet fr = Fr::random();\nlet secret_key = SecretKey::from_fr(&amp;fr);\n</code></pre>"},{"location":"api/blsttc/#serialization","title":"Serialization","text":"PythonRust <pre><code># Serialize keys and signatures\nsk_bytes = secret_key.to_bytes()\npk_bytes = public_key.to_bytes()\nsig_bytes = signature.to_bytes()\n\n# Deserialize\nsk = SecretKey.from_bytes(sk_bytes)\npk = PublicKey.from_bytes(pk_bytes)\nsig = Signature.from_bytes(sig_bytes)\n</code></pre> <pre><code>// Serialize keys and signatures\nlet sk_bytes = secret_key.to_bytes();\nlet pk_bytes = public_key.to_bytes();\nlet sig_bytes = signature.to_bytes();\n\n// Deserialize\nlet sk = SecretKey::from_bytes(&amp;sk_bytes)?;\nlet pk = PublicKey::from_bytes(&amp;pk_bytes)?;\nlet sig = Signature::from_bytes(&amp;sig_bytes)?;\n</code></pre>"},{"location":"api/blsttc/#error-handling","title":"Error Handling","text":"PythonRust <pre><code>try:\n    # Operations that might fail\n    sk = SecretKey.from_bytes(invalid_bytes)\nexcept ValueError as e:\n    print(f\"Invalid key bytes: {e}\")\n\ntry:\n    # Signature verification\n    if not pk.verify(sig, msg):\n        print(\"Invalid signature\")\nexcept Exception as e:\n    print(f\"Verification error: {e}\")\n</code></pre> <pre><code>use blsttc::error::Error;\n\n// Handle key generation errors\nmatch SecretKey::from_bytes(invalid_bytes) {\n    Ok(sk) =&gt; println!(\"Key generated successfully\"),\n    Err(Error::InvalidBytes) =&gt; println!(\"Invalid key bytes\"),\n    Err(e) =&gt; println!(\"Other error: {}\", e),\n}\n\n// Handle signature verification\nif !pk.verify(&amp;sig, msg) {\n    println!(\"Invalid signature\");\n}\n</code></pre>"},{"location":"api/blsttc/#best-practices","title":"Best Practices","text":"<ol> <li>Key Management</li> <li>Securely store private keys</li> <li>Use strong random number generation</li> <li> <p>Implement key rotation policies</p> </li> <li> <p>Threshold Selection</p> </li> <li>Choose appropriate threshold values</li> <li>Consider fault tolerance requirements</li> <li> <p>Balance security and availability</p> </li> <li> <p>Performance</p> </li> <li>Cache public keys when possible</li> <li>Batch verify signatures when possible</li> <li> <p>Use appropriate buffer sizes</p> </li> <li> <p>Security</p> </li> <li>Validate all inputs</li> <li>Use secure random number generation</li> <li>Implement proper error handling</li> </ol>"},{"location":"api/blsttc/#common-use-cases","title":"Common Use Cases","text":"<ol> <li>Distributed Key Generation</li> <li>Generate keys for distributed systems</li> <li>Share keys among multiple parties</li> <li> <p>Implement threshold cryptography</p> </li> <li> <p>Signature Aggregation</p> </li> <li>Combine multiple signatures</li> <li>Reduce signature size</li> <li> <p>Improve verification efficiency</p> </li> <li> <p>Consensus Protocols</p> </li> <li>Implement Byzantine fault tolerance</li> <li>Create distributed voting systems</li> <li>Build secure multiparty computation</li> </ol>"},{"location":"api/self-encryption/","title":"Self Encryption API Reference","text":"<p>A file content self-encryptor that provides convergent encryption on file-based data. It produces a <code>DataMap</code> type and several chunks of encrypted data. Each chunk is up to 1MB in size and has an index and a name (SHA3-256 hash of the content), allowing chunks to be self-validating.</p>"},{"location":"api/self-encryption/#installation","title":"Installation","text":"PythonRust <pre><code>pip install self-encryption\n</code></pre> <pre><code>[dependencies]\nself_encryption = \"0.31.0\"\n</code></pre>"},{"location":"api/self-encryption/#core-concepts","title":"Core Concepts","text":""},{"location":"api/self-encryption/#datamap","title":"DataMap","text":"<p>Holds the information required to recover the content of the encrypted file, stored as a vector of <code>ChunkInfo</code> (list of file's chunk hashes). Only files larger than 3072 bytes (3 * MIN_CHUNK_SIZE) can be self-encrypted.</p>"},{"location":"api/self-encryption/#chunk-sizes","title":"Chunk Sizes","text":"<ul> <li><code>MIN_CHUNK_SIZE</code>: 1 byte</li> <li><code>MAX_CHUNK_SIZE</code>: 1 MiB (before compression)</li> <li><code>MIN_ENCRYPTABLE_BYTES</code>: 3 bytes</li> </ul>"},{"location":"api/self-encryption/#streaming-operations-recommended","title":"Streaming Operations (Recommended)","text":""},{"location":"api/self-encryption/#streaming-file-encryption","title":"Streaming File Encryption","text":"PythonRust <pre><code>from self_encryption import streaming_encrypt_from_file, ChunkStore\nfrom pathlib import Path\nfrom typing import Optional\n\n# Implement your chunk store\nclass MyChunkStore(ChunkStore):\n    def put(self, name: bytes, data: bytes) -&gt; None:\n        # Store the chunk\n        pass\n\n    def get(self, name: bytes) -&gt; Optional[bytes]:\n        # Retrieve the chunk\n        pass\n\n# Create chunk store instance\nstore = MyChunkStore()\n\n# Encrypt file using streaming\nfile_path = Path(\"my_file.txt\")\ndata_map = streaming_encrypt_from_file(file_path, store)\n</code></pre> <pre><code>use self_encryption::{streaming_encrypt_from_file, ChunkStore};\nuse std::path::Path;\n\n// Implement your chunk store\nstruct MyChunkStore {\n    // Your storage implementation\n}\n\nimpl ChunkStore for MyChunkStore {\n    fn put(&amp;mut self, name: &amp;[u8], data: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {\n        // Store the chunk\n    }\n\n    fn get(&amp;self, name: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {\n        // Retrieve the chunk\n    }\n}\n\n// Create chunk store instance\nlet store = MyChunkStore::new();\n\n// Encrypt file using streaming\nlet file_path = Path::new(\"my_file.txt\");\nlet data_map = streaming_encrypt_from_file(file_path, store).await?;\n</code></pre>"},{"location":"api/self-encryption/#streaming-file-decryption","title":"Streaming File Decryption","text":"PythonRust <pre><code>from self_encryption import streaming_decrypt_from_storage\nfrom pathlib import Path\n\n# Decrypt to file using streaming\noutput_path = Path(\"decrypted_file.txt\")\nstreaming_decrypt_from_storage(data_map, store, output_path)\n</code></pre> <pre><code>use self_encryption::streaming_decrypt_from_storage;\nuse std::path::Path;\n\n// Decrypt to file using streaming\nlet output_path = Path::new(\"decrypted_file.txt\");\nstreaming_decrypt_from_storage(&amp;data_map, store, output_path).await?;\n</code></pre>"},{"location":"api/self-encryption/#in-memory-operations-small-files","title":"In-Memory Operations (Small Files)","text":""},{"location":"api/self-encryption/#basic-encryptiondecryption","title":"Basic Encryption/Decryption","text":"PythonRust <pre><code>from self_encryption import encrypt, decrypt\n\n# Encrypt bytes in memory\ndata = b\"Small data to encrypt\"\ndata_map, encrypted_chunks = encrypt(data)\n\n# Decrypt using retrieval function\ndef get_chunk(name: bytes) -&gt; bytes:\n    # Retrieve chunk by name from your storage\n    return chunk_data\n\ndecrypted = decrypt(data_map, get_chunk)\n</code></pre> <pre><code>use self_encryption::{encrypt, decrypt};\n\n// Encrypt bytes in memory\nlet data = b\"Small data to encrypt\";\nlet (data_map, encrypted_chunks) = encrypt(data)?;\n\n// Decrypt using retrieval function\nlet decrypted = decrypt(\n    &amp;data_map,\n    |name| {\n        // Retrieve chunk by name from your storage\n        Ok(chunk_data)\n    }\n)?;\n</code></pre>"},{"location":"api/self-encryption/#chunk-store-implementations","title":"Chunk Store Implementations","text":""},{"location":"api/self-encryption/#in-memory-store","title":"In-Memory Store","text":"PythonRust <pre><code>from self_encryption import ChunkStore\nfrom typing import Dict, Optional\n\nclass MemoryStore(ChunkStore):\n    def __init__(self):\n        self.chunks: Dict[bytes, bytes] = {}\n\n    def put(self, name: bytes, data: bytes) -&gt; None:\n        self.chunks[name] = data\n\n    def get(self, name: bytes) -&gt; Optional[bytes]:\n        return self.chunks.get(name)\n</code></pre> <pre><code>use std::collections::HashMap;\n\nstruct MemoryStore {\n    chunks: HashMap&lt;Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;,\n}\n\nimpl ChunkStore for MemoryStore {\n    fn put(&amp;mut self, name: &amp;[u8], data: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {\n        self.chunks.insert(name.to_vec(), data.to_vec());\n        Ok(())\n    }\n\n    fn get(&amp;self, name: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {\n        self.chunks.get(name)\n            .cloned()\n            .ok_or(Error::NoSuchChunk)\n    }\n}\n</code></pre>"},{"location":"api/self-encryption/#disk-based-store","title":"Disk-Based Store","text":"PythonRust <pre><code>from pathlib import Path\nfrom typing import Optional\nimport os\n\nclass DiskStore(ChunkStore):\n    def __init__(self, root_dir: Path):\n        self.root_dir = root_dir\n        self.root_dir.mkdir(parents=True, exist_ok=True)\n\n    def put(self, name: bytes, data: bytes) -&gt; None:\n        path = self.root_dir / name.hex()\n        path.write_bytes(data)\n\n    def get(self, name: bytes) -&gt; Optional[bytes]:\n        path = self.root_dir / name.hex()\n        try:\n            return path.read_bytes()\n        except FileNotFoundError:\n            return None\n</code></pre> <pre><code>use std::path::PathBuf;\nuse std::fs;\n\nstruct DiskStore {\n    root_dir: PathBuf,\n}\n\nimpl ChunkStore for DiskStore {\n    fn put(&amp;mut self, name: &amp;[u8], data: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {\n        let path = self.root_dir.join(hex::encode(name));\n        fs::write(path, data)?;\n        Ok(())\n    }\n\n    fn get(&amp;self, name: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {\n        let path = self.root_dir.join(hex::encode(name));\n        fs::read(path).map_err(|_| Error::NoSuchChunk)\n    }\n}\n\nimpl DiskStore {\n    fn new&lt;P: Into&lt;PathBuf&gt;&gt;(root: P) -&gt; Self {\n        let root_dir = root.into();\n        fs::create_dir_all(&amp;root_dir).expect(\"Failed to create store directory\");\n        Self { root_dir }\n    }\n}\n</code></pre>"},{"location":"api/self-encryption/#error-handling","title":"Error Handling","text":"<p>The library provides an <code>Error</code> enum for handling various error cases:</p> <pre><code>pub enum Error {\n    NoSuchChunk,\n    ChunkTooSmall,\n    ChunkTooLarge,\n    InvalidChunkSize,\n    Io(std::io::Error),\n    Serialisation(Box&lt;bincode::ErrorKind&gt;),\n    Compression(std::io::Error),\n    // ... other variants\n}\n</code></pre>"},{"location":"api/self-encryption/#best-practices","title":"Best Practices","text":"<ol> <li>Use streaming operations (<code>streaming_encrypt_from_file</code> and <code>streaming_decrypt_from_storage</code>) for large files</li> <li>Use basic <code>encrypt</code>/<code>decrypt</code> functions for small in-memory data</li> <li>Implement proper error handling for chunk store operations</li> <li>Verify chunks using their content hash when retrieving</li> <li>Use parallel operations when available for better performance</li> </ol>"},{"location":"getting-started/installation/","title":"Installation Guide","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust (latest stable)</li> <li>Python 3.8 or higher</li> <li>Node.js 16 or higher</li> </ul>"},{"location":"getting-started/installation/#api-specific-installation","title":"API-specific Installation","text":"<p>Choose the APIs you need for your project:</p>"},{"location":"getting-started/installation/#autonomi-client","title":"Autonomi Client","text":"Node.jsPythonRust <pre><code># Note: Package not yet published to npm\n# Clone the repository and build from source\ngit clone https://github.com/dirvine/autonomi.git\ncd autonomi\nnpm install\n</code></pre> <pre><code>pip install autonomi\n</code></pre> <pre><code># Add to Cargo.toml:\n[dependencies]\nautonomi = \"0.3.1\"\n</code></pre>"},{"location":"getting-started/installation/#ant-node","title":"Ant Node","text":"PythonRust <pre><code>pip install antnode\n</code></pre> <pre><code>[dependencies]\nant-node = \"0.3.2\"\n</code></pre>"},{"location":"getting-started/installation/#bls-threshold-crypto","title":"BLS Threshold Crypto","text":"PythonRust <pre><code>pip install blsttc\n</code></pre> <pre><code>[dependencies]\nblsttc = \"8.0.2\"\n</code></pre>"},{"location":"getting-started/installation/#self-encryption","title":"Self Encryption","text":"PythonRust <pre><code>pip install self-encryption\n</code></pre> <pre><code>[dependencies]\nself_encryption = \"0.28.0\"\n</code></pre>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>Test your installation by running a simple client initialization:</p> Node.jsPythonRust <pre><code>import { Client } from 'autonomi';\n\nconst client = await Client.initReadOnly();\nconsole.log('Client initialized successfully');\n</code></pre> <pre><code>from autonomi import Client\n\nclient = Client.init_read_only()\nprint('Client initialized successfully')\n</code></pre> <pre><code>use autonomi::Client;\n\nlet client = Client::new_local().await?;\nprintln!(\"Client initialized successfully\");\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>API References:</li> <li>Autonomi Client</li> <li>Ant Node</li> <li>BLS Threshold Crypto</li> <li>Self Encryption</li> <li>Local Network Setup</li> </ul>"},{"location":"guides/client_modes/","title":"Client Modes Guide","text":"<p>This guide explains how to use Autonomi's client modes to browse the network (read-only) and optionally upgrade to write capabilities.</p>"},{"location":"guides/client_modes/#overview","title":"Overview","text":"<p>Autonomi clients can operate in two modes:</p> <ol> <li>Read-Only Mode: Browse and read data from the network without requiring a wallet</li> <li>Read-Write Mode: Full access to both read and write operations, requires a wallet</li> </ol>"},{"location":"guides/client_modes/#read-only-client","title":"Read-Only Client","text":"<p>A read-only client allows you to browse and read data from the network without needing a wallet or making payments.</p>"},{"location":"guides/client_modes/#rust","title":"Rust","text":"<pre><code>use autonomi::Client;\n\n// Initialize a read-only client\nlet client = Client::init_read_only().await?;\n\n// Verify it's read-only\nassert!(!client.can_write());\nassert!(client.wallet().is_none());\n\n// Read operations work normally\nlet data = client.get_bytes(address).await?;\nlet file = client.get_file(file_map, \"output.txt\").await?;\n</code></pre>"},{"location":"guides/client_modes/#typescriptjavascript","title":"TypeScript/JavaScript","text":"<pre><code>import { Client } from '@autonomi/client';\n\n// Initialize a read-only client\nconst client = await Client.connect({\n    readOnly: true,\n    peers: ['/ip4/127.0.0.1/tcp/12000']\n});\n\n// Read operations\nconst data = await client.dataGetPublic(address);\nconst list = await client.linkedListGet(listAddress);\n</code></pre>"},{"location":"guides/client_modes/#python","title":"Python","text":"<pre><code>from autonomi import Client\n\n# Initialize a read-only client\nclient = Client.new()\n\n# Read operations\ndata = client.get_bytes(\"safe://example_address\")\nfile = client.get_file(file_map, \"output.txt\")\n</code></pre>"},{"location":"guides/client_modes/#upgrading-to-read-write-mode","title":"Upgrading to Read-Write Mode","text":"<p>You can upgrade a read-only client to read-write mode by adding a wallet. This enables write operations like storing data or updating linked lists.</p>"},{"location":"guides/client_modes/#rust_1","title":"Rust","text":"<pre><code>use autonomi::{Client, EvmWallet};\n\n// Start with a read-only client\nlet mut client = Client::init_read_only().await?;\n\n// Get a wallet (e.g., from a private key or create new)\nlet wallet = EvmWallet::from_private_key(private_key)?;\n\n// Upgrade to read-write mode\nclient.upgrade_to_read_write(wallet)?;\n\n// Now write operations are available\nlet address = client.store_bytes(data).await?;\n</code></pre>"},{"location":"guides/client_modes/#typescriptjavascript_1","title":"TypeScript/JavaScript","text":"<pre><code>import { Client } from '@autonomi/client';\n\n// Start with a read-only client\nconst client = await Client.connect({\n    readOnly: true\n});\n\n// Upgrade with a wallet\nawait client.upgradeToReadWrite({\n    type: 'wallet',\n    wallet: 'your_wallet_address'\n});\n\n// Now you can perform write operations\nconst address = await client.dataPutPublic(\n    Buffer.from('Hello World'),\n    { type: 'wallet', wallet: client.wallet }\n);\n</code></pre>"},{"location":"guides/client_modes/#python_1","title":"Python","text":"<pre><code>from autonomi import Client, Wallet\n\n# Start with a read-only client\nclient = Client.new()\n\n# Create or import a wallet\nwallet = Wallet.from_private_key(\"your_private_key\")\n\n# Upgrade to read-write mode\nclient.upgrade_to_read_write(wallet)\n\n# Now write operations are available\naddress = client.store_bytes(b\"Hello World\")\n</code></pre>"},{"location":"guides/client_modes/#write-operations","title":"Write Operations","text":"<p>The following operations require a wallet (read-write mode):</p> <ul> <li>Storing public data (<code>dataPutPublic</code>)</li> <li>Creating/updating linked lists (<code>linkedListPut</code>)</li> <li>Setting pointers (<code>pointerPut</code>)</li> <li>Writing to vaults (<code>writeBytesToVault</code>)</li> <li>Updating user data (<code>putUserDataToVault</code>)</li> </ul> <p>Attempting these operations in read-only mode will result in an error.</p>"},{"location":"guides/client_modes/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Start Read-Only: Begin with a read-only client if you only need to read data. This is simpler and more secure since no wallet is needed.</p> </li> <li> <p>Lazy Wallet Loading: Only upgrade to read-write mode when you actually need to perform write operations.</p> </li> <li> <p>Error Handling: Always handle potential errors when upgrading modes or performing write operations:</p> </li> </ol> <pre><code>try {\n    await client.upgradeToReadWrite(wallet);\n    await client.dataPutPublic(data, payment);\n} catch (error) {\n    if (error.code === 'NO_WALLET') {\n        console.error('Write operation attempted without wallet');\n    } else if (error.code === 'ALREADY_READ_WRITE') {\n        console.error('Client is already in read-write mode');\n    }\n}\n</code></pre> <ol> <li>Check Capabilities: Use the provided methods to check client capabilities:</li> </ol> <pre><code>if client.can_write() {\n    // Perform write operation\n} else {\n    // Handle read-only state\n}\n</code></pre>"},{"location":"guides/client_modes/#common-issues","title":"Common Issues","text":"<ol> <li>Attempting Write Operations in Read-Only Mode</li> <li>Error: <code>NO_WALLET</code> or <code>WriteAccessRequired</code></li> <li> <p>Solution: Upgrade to read-write mode by adding a wallet</p> </li> <li> <p>Multiple Upgrade Attempts</p> </li> <li>Error: <code>ALREADY_READ_WRITE</code></li> <li> <p>Solution: Check client mode before attempting upgrade</p> </li> <li> <p>Invalid Wallet</p> </li> <li>Error: <code>InvalidWallet</code> or <code>WalletError</code></li> <li>Solution: Ensure wallet is properly initialized with valid credentials</li> </ol>"},{"location":"guides/data_storage/","title":"Data Storage Guide","text":"<p>This guide explains how Autonomi handles data storage, including self-encryption and scratchpad features.</p>"},{"location":"guides/data_storage/#self-encryption","title":"Self-Encryption","text":"<p>Self-encryption is a core feature that provides secure data storage by splitting and encrypting data into chunks.</p>"},{"location":"guides/data_storage/#how-it-works","title":"How It Works","text":"<ol> <li>Data is split into chunks</li> <li>Each chunk is encrypted</li> <li>A data map is created to track the chunks</li> <li>Additional encryption layers are added for larger files</li> </ol>"},{"location":"guides/data_storage/#usage-examples","title":"Usage Examples","text":"Node.jsPythonRust <pre><code>import { Client } from '@autonomi/client';\n\nasync function storeEncryptedData(data: Uint8Array) {\n    const client = new Client();\n\n    // Data is automatically self-encrypted when stored\n    const address = await client.data_put_public(data);\n    console.log(`Data stored at: ${address}`);\n\n    // Retrieve and decrypt data\n    const retrieved = await client.data_get_public(address);\n    console.log('Data retrieved successfully');\n}\n</code></pre> <pre><code>from autonomi import Client\n\nasync def store_encrypted_data(data: bytes):\n    client = Client()\n\n    # Data is automatically self-encrypted when stored\n    address = await client.data_put_public(data)\n    print(f\"Data stored at: {address}\")\n\n    # Retrieve and decrypt data\n    retrieved = await client.data_get_public(address)\n    print(\"Data retrieved successfully\")\n</code></pre> <pre><code>use autonomi::{Client, Bytes, Result};\n\nasync fn store_encrypted_data(data: Bytes) -&gt; Result&lt;()&gt; {\n    let client = Client::new()?;\n\n    // Data is automatically self-encrypted when stored\n    let address = client.data_put_public(data).await?;\n    println!(\"Data stored at: {}\", address);\n\n    // Retrieve and decrypt data\n    let retrieved = client.data_get_public(&amp;address).await?;\n    println!(\"Data retrieved successfully\");\n\n    Ok(())\n}\n</code></pre>"},{"location":"guides/data_storage/#scratchpad","title":"Scratchpad","text":"<p>Scratchpad provides a mutable storage location for encrypted data with versioning support.</p>"},{"location":"guides/data_storage/#features","title":"Features","text":"<ul> <li>Mutable data storage</li> <li>Version tracking with monotonic counter</li> <li>Owner-based access control</li> <li>Data encryption</li> <li>Signature verification</li> </ul>"},{"location":"guides/data_storage/#usage-examples_1","title":"Usage Examples","text":"Node.jsPythonRust <pre><code>import { Client, Scratchpad } from '@autonomi/client';\n\nasync function useScratchpad() {\n    const client = new Client();\n    const secretKey = await client.generate_secret_key();\n\n    // Create or get existing scratchpad\n    const [scratchpad, isNew] = await client.get_or_create_scratchpad(\n        secretKey,\n        42 // content type\n    );\n\n    // Update scratchpad data\n    const data = new TextEncoder().encode('Hello World');\n    await client.update_scratchpad(scratchpad, data, secretKey);\n\n    // Read scratchpad data\n    const retrieved = await client.get_scratchpad(scratchpad.address);\n    const decrypted = await client.decrypt_scratchpad(retrieved, secretKey);\n    console.log(new TextDecoder().decode(decrypted));\n}\n</code></pre> <pre><code>from autonomi import Client, Scratchpad\n\nasync def use_scratchpad():\n    client = Client()\n    secret_key = client.generate_secret_key()\n\n    # Create or get existing scratchpad\n    scratchpad, is_new = await client.get_or_create_scratchpad(\n        secret_key,\n        42  # content type\n    )\n\n    # Update scratchpad data\n    data = b\"Hello World\"\n    await client.update_scratchpad(scratchpad, data, secret_key)\n\n    # Read scratchpad data\n    retrieved = await client.get_scratchpad(scratchpad.address)\n    decrypted = await client.decrypt_scratchpad(retrieved, secret_key)\n    print(decrypted.decode())\n</code></pre> <pre><code>use autonomi::{Client, Scratchpad, SecretKey, Bytes, Result};\n\nasync fn use_scratchpad() -&gt; Result&lt;()&gt; {\n    let client = Client::new()?;\n    let secret_key = SecretKey::random();\n\n    // Create or get existing scratchpad\n    let (mut scratchpad, is_new) = client\n        .get_or_create_scratchpad(&amp;secret_key, 42)\n        .await?;\n\n    // Update scratchpad data\n    let data = Bytes::from(\"Hello World\");\n    scratchpad.update_and_sign(data, &amp;secret_key);\n\n    // Store updated scratchpad\n    client.put_scratchpad(&amp;scratchpad).await?;\n\n    // Read scratchpad data\n    let retrieved = client.get_scratchpad(scratchpad.address()).await?;\n    let decrypted = retrieved.decrypt_data(&amp;secret_key)?;\n    println!(\"Data: {}\", String::from_utf8_lossy(&amp;decrypted));\n\n    Ok(())\n}\n</code></pre>"},{"location":"guides/data_storage/#best-practices","title":"Best Practices","text":"<ol> <li>Version Management</li> <li>Always check the counter before updates</li> <li>Handle version conflicts appropriately</li> <li> <p>Use monotonic counters for ordering</p> </li> <li> <p>Security</p> </li> <li>Keep secret keys secure</li> <li>Verify signatures before trusting data</li> <li> <p>Always encrypt sensitive data</p> </li> <li> <p>Error Handling</p> </li> <li>Handle decryption failures gracefully</li> <li>Implement proper retry logic for network operations</li> <li> <p>Validate data before storage</p> </li> <li> <p>Performance</p> </li> <li>Cache frequently accessed data</li> <li>Batch updates when possible</li> <li>Monitor storage size</li> </ol>"},{"location":"guides/data_storage/#implementation-details","title":"Implementation Details","text":""},{"location":"guides/data_storage/#self-encryption-process","title":"Self-Encryption Process","text":"<ol> <li>Data Splitting</li> </ol> <pre><code>// Internal process when storing data\nlet (data_map, chunks) = self_encryption::encrypt(data)?;\nlet (data_map_chunk, additional_chunks) = pack_data_map(data_map)?;\n</code></pre> <ol> <li>Chunk Management</li> <li>Each chunk is stored separately</li> <li>Chunks are encrypted individually</li> <li>Data maps track chunk locations</li> </ol>"},{"location":"guides/data_storage/#scratchpad-structure","title":"Scratchpad Structure","text":"<pre><code>pub struct Scratchpad {\n    // Network address\n    address: ScratchpadAddress,\n    // Data type identifier\n    data_encoding: u64,\n    // Encrypted content\n    encrypted_data: Bytes,\n    // Version counter\n    counter: u64,\n    // Owner's signature\n    signature: Option&lt;Signature&gt;,\n}\n</code></pre>"},{"location":"guides/data_storage/#advanced-topics","title":"Advanced Topics","text":""},{"location":"guides/data_storage/#custom-data-types","title":"Custom Data Types","text":"<p>You can use scratchpads to store any custom data type by implementing proper serialization:</p> <pre><code>#[derive(Serialize, Deserialize)]\nstruct CustomData {\n    field1: String,\n    field2: u64,\n}\n\n// Serialize before storing\nlet custom_data = CustomData {\n    field1: \"test\".into(),\n    field2: 42,\n};\nlet bytes = serde_json::to_vec(&amp;custom_data)?;\nscratchpad.update_and_sign(Bytes::from(bytes), &amp;secret_key);\n</code></pre>"},{"location":"guides/data_storage/#batch-operations","title":"Batch Operations","text":"<p>For better performance when dealing with multiple data items:</p> <pre><code>async fn batch_store(items: Vec&lt;Bytes&gt;) -&gt; Result&lt;Vec&lt;ChunkAddress&gt;&gt; {\n    let mut addresses = Vec::new();\n    for item in items {\n        let (data_map_chunk, chunks) = encrypt(item)?;\n        // Store chunks in parallel\n        futures::future::join_all(chunks.iter().map(|c| store_chunk(c))).await;\n        addresses.push(data_map_chunk.address());\n    }\n    Ok(addresses)\n}\n</code></pre>"},{"location":"guides/data_types/","title":"Data Types Guide","text":"<p>This guide explains the fundamental data types in Autonomi and how they can be used to build higher-level abstractions like files and directories.</p>"},{"location":"guides/data_types/#fundamental-data-types","title":"Fundamental Data Types","text":"<p>Autonomi provides four fundamental data types that serve as building blocks for all network operations. Each type is designed for specific use cases and together they provide a complete system for decentralized data management.</p>"},{"location":"guides/data_types/#1-chunk","title":"1. Chunk","text":"<p>Chunks are the foundation of secure data storage in Autonomi, primarily used as the output of self-encrypting files. This provides quantum-secure encryption for data at rest.</p> <pre><code>// Store raw bytes as a chunk\nlet data = b\"Hello, World!\";\nlet chunk_address = client.store_chunk(data).await?;\n\n// Retrieve chunk data\nlet retrieved = client.get_chunk(chunk_address).await?;\nassert_eq!(data, retrieved);\n</code></pre> <p>Key characteristics: - Quantum-secure encryption through self-encryption - Immutable content - Content-addressed (address is derived from data) - Size-limited (maximum chunk size) - Efficient for small to medium-sized data</p>"},{"location":"guides/data_types/#self-encryption-process","title":"Self-Encryption Process","text":"<ol> <li>Data is split into fixed-size sections</li> <li>Each section is encrypted using data from other sections</li> <li>Results in multiple encrypted chunks</li> <li>Original data can only be recovered with all chunks</li> </ol>"},{"location":"guides/data_types/#2-pointer","title":"2. Pointer","text":"<p>Pointers provide a fixed network address that can reference any other data type, including other pointers. They enable mutable data structures while maintaining stable addresses.</p> <pre><code>// Create a pointer to some data\nlet pointer = client.create_pointer(target_address).await?;\n\n// Update pointer target\nclient.update_pointer(pointer.address(), new_target_address).await?;\n\n// Resolve pointer to get current target\nlet target = client.resolve_pointer(pointer.address()).await?;\n\n// Chain pointers for indirection\nlet pointer_to_pointer = client.create_pointer(pointer.address()).await?;\n</code></pre> <p>Key characteristics: - Fixed network address - Mutable reference capability - Single owner (controlled by secret key) - Version tracking with monotonic counter - Atomic updates - Support for pointer chains and indirection</p>"},{"location":"guides/data_types/#common-use-cases","title":"Common Use Cases","text":"<ol> <li> <p>Mutable Data References <pre><code>// Update data while maintaining same address\nlet pointer = client.create_pointer(initial_data).await?;\nclient.update_pointer(pointer.address(), updated_data).await?;\n</code></pre></p> </li> <li> <p>Latest Version Publishing <pre><code>// Point to latest version while maintaining history\nlet history = client.create_linked_list().await?;\nlet latest = client.create_pointer(history.address()).await?;\n</code></pre></p> </li> <li> <p>Indirection and Redirection <pre><code>// Create chain of pointers for flexible data management\nlet data_pointer = client.create_pointer(data).await?;\nlet redirect_pointer = client.create_pointer(data_pointer.address()).await?;\n</code></pre></p> </li> </ol>"},{"location":"guides/data_types/#3-linkedlist","title":"3. LinkedList","text":"<p>LinkedLists in Autonomi are powerful structures that can form transaction chains or decentralized Directed Acyclic Graphs (DAGs) on the network. They provide both historical tracking and CRDT-like properties.</p> <pre><code>// Create a new linked list\nlet list = client.create_linked_list().await?;\n\n// Append items to create history\nclient.append_to_list(list.address(), item1).await?;\nclient.append_to_list(list.address(), item2).await?;\n\n// Read list contents including history\nlet items = client.get_list(list.address()).await?;\n\n// Check for forks\nlet forks = client.detect_forks(list.address()).await?;\n</code></pre> <p>Key characteristics: - Decentralized DAG structure - Fork detection and handling - Transaction chain support - CRDT-like conflict resolution - Version history tracking - Support for value transfer (cryptocurrency-like)</p>"},{"location":"guides/data_types/#dag-properties","title":"DAG Properties","text":"<ol> <li> <p>Fork Detection <pre><code>// Detect and handle forks in the list\nmatch client.detect_forks(list.address()).await? {\n    Fork::None =&gt; proceed_with_updates(),\n    Fork::Detected(branches) =&gt; resolve_conflict(branches),\n}\n</code></pre></p> </li> <li> <p>Transaction Chains <pre><code>// Create a transaction chain\nlet transaction = Transaction {\n    previous: Some(last_tx_hash),\n    amount: 100,\n    recipient: address,\n};\nclient.append_to_list(chain.address(), transaction).await?;\n</code></pre></p> </li> <li> <p>History Tracking <pre><code>// Get full history of changes\nlet history = client.get_list_history(list.address()).await?;\nfor entry in history {\n    println!(\"Version {}: {:?}\", entry.version, entry.data);\n}\n</code></pre></p> </li> </ol>"},{"location":"guides/data_types/#4-scratchpad","title":"4. ScratchPad","text":"<p>ScratchPad provides a flexible, unstructured data storage mechanism with CRDT properties through counter-based versioning. It's ideal for user account data, application configurations, and other frequently updated small data packets.</p> <pre><code>// Create a scratchpad for user settings\nlet pad = client.create_scratchpad(ContentType::UserSettings).await?;\n\n// Update with encrypted data\nlet encrypted = encrypt_aes(settings_data, user_key)?;\nclient.update_scratchpad(pad.address(), encrypted).await?;\n\n// Read and decrypt current data\nlet encrypted = client.get_scratchpad(pad.address()).await?;\nlet settings = decrypt_aes(encrypted, user_key)?;\n</code></pre> <p>Key characteristics: - Unstructured data storage - Counter-based CRDT for conflict resolution - Type-tagged content - Support for user-managed encryption - Efficient for frequent updates - Ideal for small data packets</p>"},{"location":"guides/data_types/#security-considerations","title":"Security Considerations","text":"<ol> <li> <p>Encryption <pre><code>// Example of AES encryption for scratchpad data\nlet key = generate_aes_key();\nlet encrypted = aes_encrypt(data, key)?;\nclient.update_scratchpad(pad.address(), encrypted).await?;\n</code></pre></p> </li> <li> <p>Access Control <pre><code>// Create encrypted scratchpad with access control\nlet (public_key, private_key) = generate_keypair();\nlet encrypted_key = encrypt_with_public_key(aes_key, public_key);\nlet metadata = ScratchpadMetadata {\n    encrypted_key,\n    allowed_users: vec![public_key],\n};\nclient.create_scratchpad_with_access(metadata).await?;\n</code></pre></p> </li> </ol>"},{"location":"guides/data_types/#common-applications","title":"Common Applications","text":"<ol> <li> <p>User Profiles <pre><code>// Store encrypted user profile\nlet profile = UserProfile { name, settings };\nlet encrypted = encrypt_profile(profile, user_key);\nclient.update_scratchpad(profile_pad, encrypted).await?;\n</code></pre></p> </li> <li> <p>Application State <pre><code>// Maintain application configuration\nlet config = AppConfig { preferences, state };\nlet pad = client.get_or_create_config_pad().await?;\nclient.update_scratchpad(pad, config).await?;\n</code></pre></p> </li> <li> <p>Temporary Storage <pre><code>// Use as temporary workspace\nlet workspace = client.create_scratchpad(ContentType::Workspace).await?;\nclient.update_scratchpad(workspace, working_data).await?;\n</code></pre></p> </li> </ol>"},{"location":"guides/data_types/#higher-level-abstractions","title":"Higher-Level Abstractions","text":"<p>These fundamental types can be combined to create higher-level data structures:</p>"},{"location":"guides/data_types/#file-system","title":"File System","text":"<p>The Autonomi file system is built on top of these primitives:</p> <pre><code>// Create a directory\nlet dir = client.create_directory(\"my_folder\").await?;\n\n// Create a file\nlet file = client.create_file(\"example.txt\", content).await?;\n\n// Add file to directory\nclient.add_to_directory(dir.address(), file.address()).await?;\n\n// List directory contents\nlet entries = client.list_directory(dir.address()).await?;\n</code></pre>"},{"location":"guides/data_types/#files","title":"Files","text":"<p>Files are implemented using a combination of chunks and pointers:</p> <ul> <li>Large files are split into chunks</li> <li>File metadata stored in pointer</li> <li>Content addressing for deduplication</li> </ul> <pre><code>// Store a large file\nlet file_map = client.store_file(\"large_file.dat\").await?;\n\n// Read file contents\nclient.get_file(file_map, \"output.dat\").await?;\n</code></pre>"},{"location":"guides/data_types/#directories","title":"Directories","text":"<p>Directories use linked lists and pointers to maintain a mutable collection of entries:</p> <ul> <li>LinkedList stores directory entries</li> <li>Pointer maintains current directory state</li> <li>Hierarchical structure support</li> </ul> <pre><code>// Create nested directory structure\nlet root = client.create_directory(\"/\").await?;\nlet docs = client.create_directory(\"docs\").await?;\nclient.add_to_directory(root.address(), docs.address()).await?;\n\n// List recursively\nlet tree = client.list_recursive(root.address()).await?;\n</code></pre>"},{"location":"guides/data_types/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/data_types/#data-organization","title":"Data Organization","text":"<ol> <li>Static Content</li> <li>Use chunks for immutable data</li> <li>Content addressing enables deduplication</li> <li> <p>Efficient for read-heavy workloads</p> </li> <li> <p>Mutable References</p> </li> <li>Use pointers for updateable references</li> <li>Maintain stable addresses</li> <li> <p>Version tracking built-in</p> </li> <li> <p>Collections</p> </li> <li>Use linked lists for ordered data</li> <li>Efficient for append operations</li> <li> <p>Good for logs and sequences</p> </li> <li> <p>Temporary Storage</p> </li> <li>Use scratchpads for working data</li> <li>Frequent updates supported</li> <li>Type-tagged content</li> </ol>"},{"location":"guides/data_types/#best-practices","title":"Best Practices","text":"<ol> <li>Choose the Right Type</li> <li>Chunks for immutable data</li> <li>Pointers for mutable references</li> <li>LinkedLists for collections</li> <li> <p>ScratchPads for temporary storage</p> </li> <li> <p>Efficient Data Structures</p> </li> </ol> <pre><code>// Bad: Using chunks for frequently changing data\nlet chunk = client.store_chunk(changing_data).await?;\n\n// Good: Using scratchpad for frequently changing data\nlet pad = client.create_scratchpad(content_type).await?;\nclient.update_scratchpad(pad.address(), changing_data).await?;\n</code></pre> <ol> <li>Version Management</li> </ol> <pre><code>// Track versions with pointers\nlet versions = Vec::new();\nversions.push(pointer.version());\nclient.update_pointer(pointer.address(), new_data).await?;\nversions.push(pointer.version());\n</code></pre> <ol> <li>Error Handling</li> </ol> <pre><code>match client.get_chunk(address).await {\n    Ok(data) =&gt; process_data(data),\n    Err(ChunkError::NotFound) =&gt; handle_missing_chunk(),\n    Err(ChunkError::InvalidSize) =&gt; handle_size_error(),\n    Err(e) =&gt; handle_other_error(e),\n}\n</code></pre>"},{"location":"guides/data_types/#common-issues","title":"Common Issues","text":"<ol> <li>Size Limitations</li> <li>Chunk size limits</li> <li> <p>Solution: Split large data across multiple chunks</p> </li> <li> <p>Update Conflicts</p> </li> <li>Concurrent pointer updates</li> <li> <p>Solution: Use version checking</p> </li> <li> <p>Performance</p> </li> <li>LinkedList traversal costs</li> <li>Solution: Use appropriate data structures for access patterns</li> </ol>"},{"location":"guides/evm_integration/","title":"EVM Integration Guide","text":"<p>This guide explains how to integrate Autonomi with EVM-compatible networks for testing and development.</p>"},{"location":"guides/evm_integration/#supported-networks","title":"Supported Networks","text":"<ul> <li>Local Hardhat network</li> <li>Sepolia testnet</li> <li>Goerli testnet</li> <li>Custom EVM networks</li> </ul>"},{"location":"guides/evm_integration/#setting-up-test-networks","title":"Setting Up Test Networks","text":""},{"location":"guides/evm_integration/#local-hardhat-network","title":"Local Hardhat Network","text":"<pre><code>npx hardhat node\n</code></pre>"},{"location":"guides/evm_integration/#connecting-to-test-networks","title":"Connecting to Test Networks","text":"<pre><code>import { EvmNetwork } from '@autonomi/client';\n\nconst network = new EvmNetwork({\n  chainId: 31337, // Local hardhat network\n  rpcUrl: 'http://127.0.0.1:8545'\n});\n</code></pre>"},{"location":"guides/evm_integration/#deploying-test-contracts","title":"Deploying Test Contracts","text":"<ol> <li>Compile contracts</li> <li>Deploy using Hardhat</li> <li>Interact with contracts</li> </ol>"},{"location":"guides/evm_integration/#testing-with-different-networks","title":"Testing with Different Networks","text":"<ul> <li>Network configuration</li> <li>Gas settings</li> <li>Contract deployment</li> <li>Transaction handling</li> </ul>"},{"location":"guides/evm_integration/#best-practices","title":"Best Practices","text":"<ul> <li>Error handling</li> <li>Gas optimization</li> <li>Security considerations</li> <li>Testing strategies</li> </ul>"},{"location":"guides/local_development/","title":"Local Development Environment","text":"<p>This guide will help you set up a local development environment for building applications with Autonomi. We'll use a script that sets up a local network with all the necessary components for development and testing.</p>"},{"location":"guides/local_development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust toolchain installed</li> <li>Git repository cloned</li> <li>Basic understanding of terminal/command line</li> </ul>"},{"location":"guides/local_development/#setup-script","title":"Setup Script","text":"<p>Save the following script as <code>start-local-network.sh</code> in your project root:</p> <pre><code>#!/bin/bash\nset -e\n\n# Configuration\nNODE_DATA_DIR=\"$HOME/Library/Application Support/autonomi/node\"\nCLIENT_DATA_DIR=\"$HOME/Library/Application Support/autonomi/client\"\nEVM_PORT=4343\nEVM_RPC_URL=\"http://localhost:8545\"\nWALLET_ADDRESS=\"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\"\nTOKEN_ADDRESS=\"0x5FbDB2315678afecb367f032d93F642f64180aa3\"\nLOG_LEVEL=\"info\"\nNODE_PORT=5000\n\n# ... (rest of the script content) ...\n</code></pre> <p>Make the script executable:</p> <pre><code>chmod +x start-local-network.sh\n</code></pre>"},{"location":"guides/local_development/#using-the-development-environment","title":"Using the Development Environment","text":"<ol> <li>Start the local network:</li> </ol> <pre><code>./start-local-network.sh\n</code></pre> <ol> <li>The script will:</li> <li>Build all necessary components (ant-node, evm-testnet, ant CLI)</li> <li>Start a local EVM testnet</li> <li>Start a local Autonomi node</li> <li> <p>Set up the development environment</p> </li> <li> <p>Once running, you'll see information about:</p> </li> <li>Network endpoints</li> <li>Environment variables</li> <li>Example commands</li> </ol>"},{"location":"guides/local_development/#environment-variables","title":"Environment Variables","text":"<p>The following environment variables should be set for your development environment:</p> <pre><code>export ANT_PEERS=/ip4/127.0.0.1/udp/5000/quic-v1\nexport ANT_LOG=info\nexport CLIENT_DATA_PATH=$HOME/Library/Application Support/autonomi/client\n</code></pre>"},{"location":"guides/local_development/#example-usage","title":"Example Usage","text":""},{"location":"guides/local_development/#file-operations","title":"File Operations","text":"<p>Upload a file:</p> <pre><code>./target/debug/ant file upload path/to/file\n</code></pre> <p>Download a file:</p> <pre><code>./target/debug/ant file download &lt;file-address&gt;\n</code></pre>"},{"location":"guides/local_development/#node-operations","title":"Node Operations","text":"<p>Check node status:</p> <pre><code>./target/debug/ant node status\n</code></pre> <p>Get wallet balance:</p> <pre><code>./target/debug/ant wallet balance\n</code></pre>"},{"location":"guides/local_development/#development-tips","title":"Development Tips","text":"<ol> <li> <p>Local Testing: The local network is perfect for testing your applications without affecting the main network.</p> </li> <li> <p>Quick Iterations: Changes to your application can be tested immediately without waiting for network confirmations.</p> </li> <li> <p>Clean State: Each time you start the network, it begins with a clean state, making it ideal for testing different scenarios.</p> </li> <li> <p>Debugging: The local environment provides detailed logs and quick feedback for debugging.</p> </li> </ol>"},{"location":"guides/local_development/#customization","title":"Customization","text":"<p>You can customize the development environment by modifying the configuration variables at the top of the script:</p> <ul> <li><code>NODE_PORT</code>: Change the port the node listens on</li> <li><code>LOG_LEVEL</code>: Adjust logging verbosity (\"trace\", \"debug\", \"info\", \"warn\", \"error\")</li> <li><code>EVM_PORT</code>: Change the EVM testnet port</li> <li>Other settings as needed</li> </ul>"},{"location":"guides/local_development/#troubleshooting","title":"Troubleshooting","text":"<ol> <li> <p>Port Conflicts: If you see port-in-use errors, modify the <code>NODE_PORT</code> or <code>EVM_PORT</code> in the script.</p> </li> <li> <p>Process Cleanup: If the script fails to start, ensure no old processes are running:</p> </li> </ol> <pre><code>pkill -f \"antnode\"\npkill -f \"evm-testnet\"\n</code></pre> <ol> <li>Data Cleanup: To start completely fresh, remove the data directories:</li> </ol> <pre><code>rm -rf \"$HOME/Library/Application Support/autonomi/node\"\nrm -rf \"$HOME/Library/Application Support/autonomi/client\"\n</code></pre>"},{"location":"guides/local_network/","title":"Local Network Setup Guide","text":"<p>This guide explains how to set up and run a local Autonomi network for development and testing purposes.</p>"},{"location":"guides/local_network/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust toolchain (with <code>cargo</code> installed)</li> <li>Git (for cloning the repository)</li> </ul> <p>That's it! Everything else needed will be built from source.</p>"},{"location":"guides/local_network/#quick-start","title":"Quick Start","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/dirvine/autonomi\ncd autonomi\n</code></pre> <ol> <li>Start the local network:</li> </ol> <pre><code>./test-local.sh\n</code></pre> <p>This script will:</p> <ul> <li>Build all necessary components</li> <li>Start a local EVM testnet</li> <li>Start a local Autonomi node</li> <li>Set up the development environment</li> </ul>"},{"location":"guides/local_network/#network-components","title":"Network Components","text":"<p>The local network consists of:</p> <ul> <li>An Autonomi node running in local mode</li> <li>A local EVM test network with pre-funded accounts</li> <li>Test wallets for development</li> </ul>"},{"location":"guides/local_network/#testing-with-evm-networks","title":"Testing with EVM Networks","text":"<p>The local EVM network provides a complete testing environment for blockchain interactions:</p>"},{"location":"guides/local_network/#pre-deployed-contracts","title":"Pre-deployed Contracts","text":"<p>The following contracts are automatically deployed:</p> <ul> <li>Payment Vault Contract (<code>PaymentVaultNoProxy</code>)</li> <li>Handles data storage payments</li> <li>Manages token approvals and transfers</li> <li>Verifies payment proofs</li> <li>Test Token Contract (<code>TestToken</code>)</li> <li>ERC20 token for testing payments</li> <li>Pre-minted supply for test accounts</li> <li>Automatic approval for test wallets</li> </ul>"},{"location":"guides/local_network/#test-accounts","title":"Test Accounts","text":"<p>Several accounts are pre-funded and ready to use:</p> <pre><code>Primary Test Account:\nAddress: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\nPrivate Key: 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\nBalance: 10000 TEST tokens\n\nSecondary Test Account:\nAddress: 0x70997970C51812dc3A010C7d01b50e0d17dc79C8\nPrivate Key: 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d\nBalance: 1000 TEST tokens\n</code></pre>"},{"location":"guides/local_network/#rpc-endpoint","title":"RPC Endpoint","text":"<p>The local EVM network exposes an RPC endpoint at <code>http://localhost:8545</code> with:</p> <ul> <li>Full JSON-RPC API support</li> <li>WebSocket subscriptions</li> <li>Low block time (1 second)</li> <li>Zero gas costs</li> <li>Instant transaction confirmations</li> </ul>"},{"location":"guides/local_network/#interacting-with-the-network","title":"Interacting with the Network","text":""},{"location":"guides/local_network/#javascripttypescript","title":"JavaScript/TypeScript","text":"<pre><code>import { ethers } from 'ethers';\n\n// Connect to local network\nconst provider = new ethers.JsonRpcProvider('http://localhost:8545');\nconst wallet = new ethers.Wallet(PRIVATE_KEY, provider);\n\n// Get contract instances\nconst paymentVault = new ethers.Contract(\n  PAYMENT_VAULT_ADDRESS,\n  PAYMENT_VAULT_ABI,\n  wallet\n);\n\n// Interact with contracts\nawait paymentVault.getQuote([metrics]);\nawait paymentVault.payForQuotes(payments);\n</code></pre>"},{"location":"guides/local_network/#python","title":"Python","text":"<pre><code>from web3 import Web3\nfrom eth_account import Account\n\n# Connect to local network\nw3 = Web3(Web3.HTTPProvider('http://localhost:8545'))\naccount = Account.from_key(PRIVATE_KEY)\n\n# Get contract instances\npayment_vault = w3.eth.contract(\n    address=PAYMENT_VAULT_ADDRESS,\n    abi=PAYMENT_VAULT_ABI\n)\n\n# Interact with contracts\npayment_vault.functions.getQuote([metrics]).call()\npayment_vault.functions.payForQuotes(payments).transact()\n</code></pre>"},{"location":"guides/local_network/#rust","title":"Rust","text":"<pre><code>use ethers::prelude::*;\n\n// Connect to local network\nlet provider = Provider::&lt;Http&gt;::try_from(\"http://localhost:8545\")?;\nlet wallet = LocalWallet::from_bytes(&amp;PRIVATE_KEY)?;\nlet client = SignerMiddleware::new(provider, wallet);\n\n// Get contract instances\nlet payment_vault = PaymentVault::new(\n    PAYMENT_VAULT_ADDRESS,\n    Arc::new(client)\n);\n\n// Interact with contracts\npayment_vault.get_quote(metrics).call().await?;\npayment_vault.pay_for_quotes(payments).send().await?;\n</code></pre>"},{"location":"guides/local_network/#environment-variables","title":"Environment Variables","text":"<p>The following environment variables are set up automatically:</p> <ul> <li><code>ANT_PEERS</code> - Local node endpoint</li> <li><code>ANT_LOG</code> - Logging level</li> <li><code>CLIENT_DATA_PATH</code> - Client data directory</li> </ul>"},{"location":"guides/local_network/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"guides/local_network/#logging","title":"Logging","text":""},{"location":"guides/local_network/#node-logs","title":"Node Logs","text":"<p>The Autonomi node generates detailed logs that can be controlled via <code>RUST_LOG</code>:</p> <pre><code># Trace level for maximum detail\nRUST_LOG=trace ./test-local.sh\n\n# Focus on specific modules\nRUST_LOG=autonomi=debug,ant_node=trace ./test-local.sh\n\n# Log locations:\n- Node logs: $NODE_DATA_DIR/node.log\n- EVM logs: $NODE_DATA_DIR/evm.log\n</code></pre>"},{"location":"guides/local_network/#log-levels","title":"Log Levels","text":"<ul> <li><code>error</code>: Critical issues that need immediate attention</li> <li><code>warn</code>: Important events that aren't failures</li> <li><code>info</code>: General operational information</li> <li><code>debug</code>: Detailed information for debugging</li> <li><code>trace</code>: Very detailed protocol-level information</li> </ul>"},{"location":"guides/local_network/#following-logs","title":"Following Logs","text":"<pre><code># Follow node logs\ntail -f \"$NODE_DATA_DIR/node.log\"\n\n# Follow EVM logs\ntail -f \"$NODE_DATA_DIR/evm.log\"\n\n# Filter for specific events\ntail -f \"$NODE_DATA_DIR/node.log\" | grep \"payment\"\n</code></pre>"},{"location":"guides/local_network/#debugging","title":"Debugging","text":""},{"location":"guides/local_network/#node-debugging","title":"Node Debugging","text":"<p>Using <code>rust-lldb</code>:</p> <pre><code># Start node with debugger\nrust-lldb target/debug/antnode -- --features test\n\n# Common commands:\nb autonomi::client::payment::pay  # Set breakpoint\nr                                # Run\nbt                              # Backtrace\np variable                      # Print variable\nc                              # Continue\n</code></pre> <p>Using <code>rust-gdb</code>:</p> <pre><code># Start node with debugger\nrust-gdb target/debug/antnode -- --features test\n\n# Common commands:\nbreak autonomi::client::payment::pay  # Set breakpoint\nrun                                  # Run\nbacktrace                           # Show backtrace\nprint variable                      # Examine variable\ncontinue                            # Continue execution\n</code></pre>"},{"location":"guides/local_network/#network-monitoring","title":"Network Monitoring","text":"<p>Monitor network activity:</p> <pre><code># Watch network connections\nnetstat -an | grep 5000  # Default node port\n\n# Monitor network traffic\nsudo tcpdump -i lo0 port 5000\n\n# Check EVM network\ncurl -X POST -H \"Content-Type: application/json\" \\\n  --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1}' \\\n  http://localhost:8545\n</code></pre>"},{"location":"guides/local_network/#contract-debugging","title":"Contract Debugging","text":"<p>Debug contract interactions:</p> <pre><code># Get payment vault state\ncast call $PAYMENT_VAULT_ADDRESS \\\n  \"payments(bytes32)\" \\\n  $QUOTE_HASH \\\n  --rpc-url http://localhost:8545\n\n# Watch for payment events\ncast events $PAYMENT_VAULT_ADDRESS \\\n  --rpc-url http://localhost:8545\n</code></pre>"},{"location":"guides/local_network/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"guides/local_network/#port-conflicts","title":"Port Conflicts","text":"<p>If you see port-in-use errors:</p> <ol> <li>Check if another instance is running</li> <li>Use different ports in the script</li> <li>Kill existing processes if needed</li> </ol>"},{"location":"guides/local_network/#build-issues","title":"Build Issues","text":"<ol> <li>Make sure Rust toolchain is up to date</li> <li>Clean and rebuild: <code>cargo clean &amp;&amp; cargo build</code></li> <li>Check for missing dependencies</li> </ol>"},{"location":"guides/local_network/#network-issues","title":"Network Issues","text":"<ol> <li>Verify the node is running</li> <li>Check log output for errors</li> <li>Ensure EVM testnet is accessible</li> </ol>"},{"location":"guides/local_network/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/local_network/#custom-configuration","title":"Custom Configuration","text":"<p>You can modify the test script to:</p> <ul> <li>Change ports</li> <li>Adjust logging levels</li> <li>Configure node parameters</li> </ul>"},{"location":"guides/local_network/#multiple-nodes","title":"Multiple Nodes","text":"<p>To run multiple nodes:</p> <ol> <li>Copy the script</li> <li>Modify ports and directories</li> <li>Run each instance separately</li> </ol>"},{"location":"guides/payments/","title":"Payments Guide","text":"<p>This guide explains how payments work in Autonomi, particularly for put operations that store data on the network.</p>"},{"location":"guides/payments/#overview","title":"Overview","text":"<p>When storing data on the Autonomi network, you need to pay for the storage space. Payments are made using EVM-compatible tokens through a smart contract system. There are two ways to handle payments:</p> <ol> <li>Direct payment using an EVM wallet</li> <li>Pre-paid operations using a receipt</li> </ol>"},{"location":"guides/payments/#payment-options","title":"Payment Options","text":""},{"location":"guides/payments/#using-an-evm-wallet","title":"Using an EVM Wallet","text":"<p>The simplest way to pay for put operations is to use an EVM wallet:</p> <pre><code># Python\nfrom autonomi import Client, PaymentOption\nfrom autonomi.evm import EvmWallet\n\n# Initialize client\nclient = Client()\n\n# Create or load a wallet\nwallet = EvmWallet.create()  # or load from private key\npayment = PaymentOption.from_wallet(wallet)\n\n# Put data with wallet payment\ndata = b\"Hello, World!\"\naddress = client.data_put_public(data, payment)\n</code></pre> <pre><code>// Node.js\nimport { Client, PaymentOption } from '@autonomi/client';\nimport { EvmWallet } from '@autonomi/evm';\n\n// Initialize client\nconst client = new Client();\n\n// Create or load a wallet\nconst wallet = EvmWallet.create();  // or load from private key\nconst payment = PaymentOption.fromWallet(wallet);\n\n// Put data with wallet payment\nconst data = Buffer.from(\"Hello, World!\");\nconst address = await client.dataPutPublic(data, payment);\n</code></pre> <pre><code>// Rust\nuse autonomi::{Client, PaymentOption};\nuse ant_evm::EvmWallet;\n\n// Initialize client\nlet client = Client::new()?;\n\n// Create or load a wallet\nlet wallet = EvmWallet::create()?;  // or load from private key\nlet payment = wallet.into();  // Converts to PaymentOption\n\n// Put data with wallet payment\nlet data = b\"Hello, World!\".to_vec();\nlet address = client.data_put_public(data.into(), payment).await?;\n</code></pre>"},{"location":"guides/payments/#using-pre-paid-receipts","title":"Using Pre-paid Receipts","text":"<p>For better efficiency when doing multiple put operations, you can pre-pay for storage and reuse the receipt:</p> <pre><code># Python\nfrom autonomi import Client, PaymentOption\nfrom autonomi.evm import EvmWallet\n\n# Initialize client\nclient = Client()\nwallet = EvmWallet.create()\n\n# Get receipt for multiple operations\ndata1 = b\"First piece of data\"\ndata2 = b\"Second piece of data\"\n\n# Create payment receipt\nreceipt = client.create_payment_receipt([data1, data2], wallet)\npayment = PaymentOption.from_receipt(receipt)\n\n# Use receipt for puts\naddr1 = client.data_put_public(data1, payment)\naddr2 = client.data_put_public(data2, payment)\n</code></pre> <pre><code>// Node.js\nimport { Client, PaymentOption } from '@autonomi/client';\nimport { EvmWallet } from '@autonomi/evm';\n\n// Initialize client\nconst client = new Client();\nconst wallet = EvmWallet.create();\n\n// Get receipt for multiple operations\nconst data1 = Buffer.from(\"First piece of data\");\nconst data2 = Buffer.from(\"Second piece of data\");\n\n// Create payment receipt\nconst receipt = await client.createPaymentReceipt([data1, data2], wallet);\nconst payment = PaymentOption.fromReceipt(receipt);\n\n// Use receipt for puts\nconst addr1 = await client.dataPutPublic(data1, payment);\nconst addr2 = await client.dataPutPublic(data2, payment);\n</code></pre> <pre><code>// Rust\nuse autonomi::{Client, PaymentOption};\nuse ant_evm::EvmWallet;\n\n// Initialize client\nlet client = Client::new()?;\nlet wallet = EvmWallet::create()?;\n\n// Get receipt for multiple operations\nlet data1 = b\"First piece of data\".to_vec();\nlet data2 = b\"Second piece of data\".to_vec();\n\n// Create payment receipt\nlet receipt = client.create_payment_receipt(\n    vec![data1.clone(), data2.clone()].into_iter(), \n    &amp;wallet\n).await?;\nlet payment = receipt.into();  // Converts to PaymentOption\n\n// Use receipt for puts\nlet addr1 = client.data_put_public(data1.into(), payment.clone()).await?;\nlet addr2 = client.data_put_public(data2.into(), payment).await?;\n</code></pre>"},{"location":"guides/payments/#cost-calculation","title":"Cost Calculation","text":"<p>The cost of storing data depends on several factors:</p> <ul> <li>Size of the data</li> <li>Network density</li> <li>Storage duration</li> <li>Current network conditions</li> </ul> <p>You can calculate the cost before performing a put operation:</p> <pre><code># Python\ncost = client.calculate_storage_cost(data)\nprint(f\"Storage will cost {cost} tokens\")\n</code></pre> <pre><code>// Node.js\nconst cost = await client.calculateStorageCost(data);\nconsole.log(`Storage will cost ${cost} tokens`);\n</code></pre> <pre><code>// Rust\nlet cost = client.calculate_storage_cost(&amp;data).await?;\nprintln!(\"Storage will cost {} tokens\", cost);\n</code></pre>"},{"location":"guides/payments/#token-management","title":"Token Management","text":"<p>Before you can pay for storage, you need to ensure your wallet has sufficient tokens and has approved the payment contract to spend them:</p> <pre><code># Python\n# Check balance\nbalance = wallet.get_balance()\n\n# Approve tokens if needed\nif not wallet.has_approved_tokens():\n    wallet.approve_tokens()\n</code></pre> <pre><code>// Node.js\n// Check balance\nconst balance = await wallet.getBalance();\n\n// Approve tokens if needed\nif (!await wallet.hasApprovedTokens()) {\n    await wallet.approveTokens();\n}\n</code></pre> <pre><code>// Rust\n// Check balance\nlet balance = wallet.get_balance().await?;\n\n// Approve tokens if needed\nif !wallet.has_approved_tokens().await? {\n    wallet.approve_tokens().await?;\n}\n</code></pre>"},{"location":"guides/payments/#error-handling","title":"Error Handling","text":"<p>Common payment-related errors you might encounter:</p> <ol> <li><code>InsufficientBalance</code> - Wallet doesn't have enough tokens</li> <li><code>TokenNotApproved</code> - Token spending not approved for the payment contract</li> <li><code>PaymentExpired</code> - Payment quote has expired (when using receipts)</li> <li><code>PaymentVerificationFailed</code> - Payment verification failed on the network</li> </ol> <p>Example error handling:</p> <pre><code># Python\ntry:\n    address = client.data_put_public(data, payment)\nexcept InsufficientBalance:\n    print(\"Not enough tokens in wallet\")\nexcept TokenNotApproved:\n    print(\"Need to approve token spending\")\nexcept PaymentError as e:\n    print(f\"Payment failed: {e}\")\n</code></pre> <pre><code>// Node.js\ntry {\n    const address = await client.dataPutPublic(data, payment);\n} catch (e) {\n    if (e instanceof InsufficientBalance) {\n        console.log(\"Not enough tokens in wallet\");\n    } else if (e instanceof TokenNotApproved) {\n        console.log(\"Need to approve token spending\");\n    } else {\n        console.log(`Payment failed: ${e}`);\n    }\n}\n</code></pre> <pre><code>// Rust\nmatch client.data_put_public(data.into(), payment).await {\n    Err(PutError::InsufficientBalance) =&gt; {\n        println!(\"Not enough tokens in wallet\");\n    }\n    Err(PutError::TokenNotApproved) =&gt; {\n        println!(\"Need to approve token spending\");\n    }\n    Err(e) =&gt; {\n        println!(\"Payment failed: {}\", e);\n    }\n    Ok(address) =&gt; {\n        println!(\"Data stored at {}\", address);\n    }\n}\n</code></pre>"},{"location":"guides/payments/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Pre-approve Tokens: Approve token spending before starting put operations to avoid extra transactions.</p> </li> <li> <p>Use Receipts: When doing multiple put operations, use receipts to avoid making separate payments for each operation.</p> </li> <li> <p>Check Costs: Always check storage costs before proceeding with large data uploads.</p> </li> <li> <p>Handle Errors: Implement proper error handling for payment-related issues.</p> </li> <li> <p>Monitor Balance: Keep track of your wallet balance to ensure sufficient funds for operations.</p> </li> </ol>"},{"location":"guides/payments/#testing-payments","title":"Testing Payments","text":"<p>When testing your application, you can use the local development environment which provides a test EVM network with pre-funded wallets. See the Local Development Guide for details.</p>"},{"location":"guides/testing_guide/","title":"Testing Guide","text":"<p>This guide covers testing strategies for Autonomi applications across different languages and environments.</p>"},{"location":"guides/testing_guide/#test-environment-setup","title":"Test Environment Setup","text":""},{"location":"guides/testing_guide/#nodejs","title":"Node.js","text":"<pre><code>npm install --save-dev jest @types/jest ts-jest\n</code></pre>"},{"location":"guides/testing_guide/#python","title":"Python","text":"<pre><code>pip install pytest pytest-asyncio\n</code></pre>"},{"location":"guides/testing_guide/#rust","title":"Rust","text":"<pre><code>cargo install cargo-test\n</code></pre>"},{"location":"guides/testing_guide/#writing-tests","title":"Writing Tests","text":""},{"location":"guides/testing_guide/#nodejs-example","title":"Node.js Example","text":"<pre><code>import { Client, LinkedList } from '@autonomi/client';\n\ndescribe('LinkedList Operations', () =&gt; {\n  let client: Client;\n\n  beforeEach(() =&gt; {\n    client = new Client();\n  });\n\n  test('should store and retrieve linked list', async () =&gt; {\n    const list = new LinkedList();\n    list.append(\"test data\");\n\n    const address = await client.linkedListPut(list);\n    const retrieved = await client.linkedListGet(address);\n\n    expect(retrieved.toString()).toBe(\"test data\");\n  });\n});\n</code></pre>"},{"location":"guides/testing_guide/#python-example","title":"Python Example","text":"<pre><code>import pytest\nfrom autonomi import Client, LinkedList\n\n@pytest.mark.asyncio\nasync def test_linked_list_operations():\n    client = Client()\n\n    # Create and store list\n    list_obj = LinkedList()\n    list_obj.append(\"test data\")\n\n    address = await client.linked_list_put(list_obj)\n    retrieved = await client.linked_list_get(address)\n\n    assert str(retrieved) == \"test data\"\n</code></pre>"},{"location":"guides/testing_guide/#rust-example","title":"Rust Example","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_linked_list_operations() {\n        let client = Client::new();\n\n        let mut list = LinkedList::new();\n        list.append(\"test data\");\n\n        let address = client.linked_list_put(&amp;list).unwrap();\n        let retrieved = client.linked_list_get(&amp;address).unwrap();\n\n        assert_eq!(retrieved.to_string(), \"test data\");\n    }\n}\n</code></pre>"},{"location":"guides/testing_guide/#test-categories","title":"Test Categories","text":"<ol> <li>Unit Tests</li> <li>Integration Tests</li> <li>Network Tests</li> <li>EVM Integration Tests</li> </ol>"},{"location":"guides/testing_guide/#cicd-integration","title":"CI/CD Integration","text":"<ul> <li>GitHub Actions configuration</li> <li>Test automation</li> <li>Coverage reporting</li> </ul>"},{"location":"guides/testing_guide/#best-practices","title":"Best Practices","text":"<ul> <li>Test isolation</li> <li>Mock network calls</li> <li>Error scenarios</li> <li>Performance testing</li> </ul>"}]}